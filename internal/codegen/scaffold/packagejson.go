package scaffold

import (
	"fmt"
	"sort"
	"strings"

	"github.com/barun-bash/human/internal/codegen/storybook"
	"github.com/barun-bash/human/internal/codegen/themes"
	"github.com/barun-bash/human/internal/ir"
)

// generateRootPackageJSON produces a root package.json with npm workspaces
// that orchestrate the backend and frontend, dynamically based on stack config.
// This overwrites the Docker generator's simpler package.json.
func generateRootPackageJSON(app *ir.Application) string {
	var b strings.Builder
	name := appNameLower(app)

	frontend := ""
	backend := ""
	deploy := ""
	if app.Config != nil {
		frontend = strings.ToLower(app.Config.Frontend)
		backend = strings.ToLower(app.Config.Backend)
		deploy = strings.ToLower(app.Config.Deploy)
	}

	// Determine which workspaces exist
	var workspaces []string
	if strings.Contains(backend, "node") {
		workspaces = append(workspaces, "node")
	}
	if strings.Contains(frontend, "react") {
		workspaces = append(workspaces, "react")
	}
	if strings.Contains(frontend, "vue") {
		workspaces = append(workspaces, "vue")
	}
	if strings.Contains(frontend, "angular") {
		workspaces = append(workspaces, "angular")
	}
	if strings.Contains(frontend, "svelte") {
		workspaces = append(workspaces, "svelte")
	}

	// Determine frontend workspace name for scripts
	frontendWS := ""
	for _, ws := range []string{"react", "vue", "angular", "svelte"} {
		if strings.Contains(frontend, ws) {
			frontendWS = ws
			break
		}
	}

	b.WriteString("{\n")
	fmt.Fprintf(&b, "  \"name\": \"%s\",\n", name)
	b.WriteString("  \"version\": \"0.1.0\",\n")
	b.WriteString("  \"private\": true,\n")
	fmt.Fprintf(&b, "  \"description\": \"%s â€” generated by Human compiler\",\n", app.Name)

	if len(workspaces) > 0 {
		b.WriteString("  \"workspaces\": [\n")
		for i, ws := range workspaces {
			fmt.Fprintf(&b, "    \"%s\"", ws)
			if i < len(workspaces)-1 {
				b.WriteString(",")
			}
			b.WriteString("\n")
		}
		b.WriteString("  ],\n")
	}

	b.WriteString("  \"scripts\": {\n")

	// Build dev/start/build/test scripts based on active workspaces
	var scripts []string
	if strings.Contains(backend, "node") && frontendWS != "" {
		scripts = append(scripts,
			fmt.Sprintf("    \"dev\": \"concurrently \\\"npm run dev --workspace=node\\\" \\\"npm run dev --workspace=%s\\\"\"", frontendWS),
			fmt.Sprintf("    \"start\": \"concurrently \\\"npm run start --workspace=node\\\" \\\"npm run start --workspace=%s\\\"\"", frontendWS),
			fmt.Sprintf("    \"build\": \"npm run build --workspace=node && npm run build --workspace=%s\"", frontendWS),
			"    \"test\": \"npm run test --workspace=node\"",
		)
	} else if strings.Contains(backend, "node") {
		scripts = append(scripts,
			"    \"dev\": \"npm run dev --workspace=node\"",
			"    \"start\": \"npm run start --workspace=node\"",
			"    \"build\": \"npm run build --workspace=node\"",
			"    \"test\": \"npm run test --workspace=node\"",
		)
	} else if frontendWS != "" {
		scripts = append(scripts,
			fmt.Sprintf("    \"dev\": \"npm run dev --workspace=%s\"", frontendWS),
			fmt.Sprintf("    \"start\": \"npm run start --workspace=%s\"", frontendWS),
			fmt.Sprintf("    \"build\": \"npm run build --workspace=%s\"", frontendWS),
		)
	}

	// Prisma scripts only for Node backend
	if strings.Contains(backend, "node") {
		scripts = append(scripts,
			"    \"db:migrate\": \"cd node && npx prisma migrate deploy\"",
			"    \"db:seed\": \"cd node && npx prisma db seed\"",
			"    \"db:studio\": \"cd node && npx prisma studio\"",
		)
	}

	// Docker scripts only if deploy target is Docker
	if strings.Contains(deploy, "docker") {
		scripts = append(scripts,
			"    \"docker:dev\": \"docker compose up --build\"",
			"    \"docker:start\": \"docker compose up -d\"",
			"    \"docker:stop\": \"docker compose down\"",
		)
	}

	for i, s := range scripts {
		b.WriteString(s)
		if i < len(scripts)-1 {
			b.WriteString(",")
		}
		b.WriteString("\n")
	}
	b.WriteString("  }")

	// devDependencies only if we have multiple workspaces (need concurrently)
	if len(workspaces) > 1 {
		b.WriteString(",\n")
		b.WriteString("  \"devDependencies\": {\n")
		b.WriteString("    \"concurrently\": \"^9.0.0\"\n")
		b.WriteString("  }\n")
	} else {
		b.WriteString("\n")
	}

	b.WriteString("}\n")

	return b.String()
}

// generateNodePackageJSON produces node/package.json with Express, Prisma,
// and all backend dependencies. Integration-specific packages are injected
// based on the app's integration declarations.
func generateNodePackageJSON(app *ir.Application) string {
	name := appNameLower(app)

	deps := map[string]string{
		"@prisma/client": "^6.0.0",
		"bcryptjs":       "^2.4.3",
		"cors":           "^2.8.5",
		"express":        "^4.21.0",
		"jsonwebtoken":   "^9.0.0",
	}
	devDeps := map[string]string{
		"@types/bcryptjs":      "^2.4.6",
		"@types/cors":          "^2.8.17",
		"@types/express":       "^5.0.0",
		"@types/jest":          "^29.5.0",
		"@types/jsonwebtoken":  "^9.0.7",
		"@types/supertest":     "^6.0.0",
		"jest":                 "^29.7.0",
		"prisma":               "^6.0.0",
		"supertest":            "^7.0.0",
		"ts-jest":              "^29.2.0",
		"ts-node":              "^10.9.0",
		"typescript":           "^5.7.0",
	}

	// Inject integration-specific dependencies
	for _, integ := range app.Integrations {
		integDeps, integDevDeps := integrationDependencies(integ.Type)
		for k, v := range integDeps {
			deps[k] = v
		}
		for k, v := range integDevDeps {
			devDeps[k] = v
		}
	}

	var b strings.Builder
	b.WriteString("{\n")
	fmt.Fprintf(&b, "  \"name\": \"%s-backend\",\n", name)
	b.WriteString("  \"version\": \"0.1.0\",\n")
	b.WriteString("  \"private\": true,\n")
	b.WriteString("  \"scripts\": {\n")
	b.WriteString("    \"start\": \"node dist/server.js\",\n")
	b.WriteString("    \"dev\": \"ts-node src/server.ts\",\n")
	b.WriteString("    \"build\": \"tsc\",\n")
	b.WriteString("    \"test\": \"jest\"\n")
	b.WriteString("  },\n")

	writeSortedDepsInline := func(label string, m map[string]string) {
		fmt.Fprintf(&b, "  \"%s\": {\n", label)
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			fmt.Fprintf(&b, "    \"%s\": \"%s\"", k, m[k])
			if i < len(keys)-1 {
				b.WriteString(",")
			}
			b.WriteString("\n")
		}
		b.WriteString("  }")
	}

	writeSortedDepsInline("dependencies", deps)
	b.WriteString(",\n")
	writeSortedDepsInline("devDependencies", devDeps)
	b.WriteString("\n")
	b.WriteString("}\n")

	return b.String()
}

// integrationDependencies returns npm packages needed for a given integration type.
func integrationDependencies(integrationType string) (deps, devDeps map[string]string) {
	deps = make(map[string]string)
	devDeps = make(map[string]string)

	switch integrationType {
	case "email":
		deps["@sendgrid/mail"] = "^8.1.0"
	case "storage":
		deps["@aws-sdk/client-s3"] = "^3.700.0"
		deps["@aws-sdk/s3-request-presigner"] = "^3.700.0"
	case "payment":
		deps["stripe"] = "^17.0.0"
	case "messaging":
		deps["@slack/webhook"] = "^7.0.0"
	case "oauth":
		deps["passport"] = "^0.7.0"
		deps["passport-google-oauth20"] = "^2.0.0"
		deps["passport-github2"] = "^0.1.12"
		deps["passport-facebook"] = "^3.0.0"
		devDeps["@types/passport"] = "^1.0.16"
		devDeps["@types/passport-google-oauth20"] = "^2.0.16"
		devDeps["@types/passport-github2"] = "^1.2.9"
		devDeps["@types/passport-facebook"] = "^3.0.0"
	}

	return
}

// generateReactPackageJSON produces react/package.json with React, Vite,
// and frontend dependencies. Design system dependencies are injected
// based on the app's theme configuration.
func generateReactPackageJSON(app *ir.Application) string {
	name := appNameLower(app)

	deps := map[string]string{
		"react":            "^19.0.0",
		"react-dom":        "^19.0.0",
		"react-router-dom": "^7.0.0",
	}
	devDeps := map[string]string{
		"@types/react":         "^19.0.0",
		"@types/react-dom":     "^19.0.0",
		"@vitejs/plugin-react": "^4.3.0",
		"typescript":           "^5.7.0",
		"vite":                 "^6.0.0",
	}

	// Inject design system dependencies
	systemID := ""
	if app.Theme != nil && app.Theme.DesignSystem != "" {
		systemID = app.Theme.DesignSystem
	}

	if systemID != "" {
		dsDeps, dsDevDeps := themes.Dependencies(systemID, "react")
		for k, v := range dsDeps {
			deps[k] = v
		}
		for k, v := range dsDevDeps {
			devDeps[k] = v
		}
	} else {
		// Default: include tailwind
		devDeps["tailwindcss"] = "^3.4.0"
		devDeps["autoprefixer"] = "^10.4.0"
		devDeps["postcss"] = "^8.4.0"
	}

	// If design system needs tailwind (shadcn, tailwind, untitled), ensure it's included
	if themes.NeedsTailwind(systemID) {
		devDeps["tailwindcss"] = "^3.4.0"
		devDeps["autoprefixer"] = "^10.4.0"
		devDeps["postcss"] = "^8.4.0"
	}

	// Storybook dependencies
	for k, v := range storybook.DevDependencies("react") {
		devDeps[k] = v
	}

	return writePackageJSONWithExtra(name+"-frontend", "tsc && vite build", deps, devDeps, storybook.Scripts())
}

// generateVuePackageJSON produces vue/package.json with Vue 3, Vite,
// and frontend dependencies. Design system dependencies are injected
// based on the app's theme configuration.
func generateVuePackageJSON(app *ir.Application) string {
	name := appNameLower(app)

	deps := map[string]string{
		"vue":        "^3.5.0",
		"vue-router": "^4.4.0",
		"pinia":      "^2.2.0",
	}
	devDeps := map[string]string{
		"@vitejs/plugin-vue": "^5.2.0",
		"typescript":         "^5.7.0",
		"vite":               "^6.0.0",
		"vue-tsc":            "^2.1.0",
	}

	systemID := ""
	if app.Theme != nil && app.Theme.DesignSystem != "" {
		systemID = app.Theme.DesignSystem
	}

	if systemID != "" {
		dsDeps, dsDevDeps := themes.Dependencies(systemID, "vue")
		for k, v := range dsDeps {
			deps[k] = v
		}
		for k, v := range dsDevDeps {
			devDeps[k] = v
		}
	} else {
		devDeps["tailwindcss"] = "^3.4.0"
		devDeps["autoprefixer"] = "^10.4.0"
		devDeps["postcss"] = "^8.4.0"
	}

	if themes.NeedsTailwind(systemID) {
		devDeps["tailwindcss"] = "^3.4.0"
		devDeps["autoprefixer"] = "^10.4.0"
		devDeps["postcss"] = "^8.4.0"
	}

	// Storybook dependencies
	for k, v := range storybook.DevDependencies("vue") {
		devDeps[k] = v
	}

	return writePackageJSONWithExtra(name+"-frontend", "vue-tsc && vite build", deps, devDeps, storybook.Scripts())
}

// writePackageJSON produces a formatted package.json from sorted dependency maps.
// The buildCmd parameter controls the "build" script (e.g. "tsc && vite build" for React,
// "vue-tsc && vite build" for Vue).
func writePackageJSON(pkgName, buildCmd string, deps, devDeps map[string]string) string {
	return writePackageJSONWithExtra(pkgName, buildCmd, deps, devDeps, nil)
}

// writePackageJSONWithExtra is like writePackageJSON but accepts extra scripts
// to merge into the scripts section (e.g. Storybook scripts).
func writePackageJSONWithExtra(pkgName, buildCmd string, deps, devDeps map[string]string, extraScripts map[string]string) string {
	var b strings.Builder

	b.WriteString("{\n")
	fmt.Fprintf(&b, "  \"name\": \"%s\",\n", pkgName)
	b.WriteString("  \"version\": \"0.1.0\",\n")
	b.WriteString("  \"private\": true,\n")
	b.WriteString("  \"type\": \"module\",\n")
	b.WriteString("  \"scripts\": {\n")
	b.WriteString("    \"dev\": \"vite\",\n")
	fmt.Fprintf(&b, "    \"build\": \"%s\",\n", buildCmd)
	b.WriteString("    \"preview\": \"vite preview\",\n")
	b.WriteString("    \"start\": \"vite preview\"")

	// Merge extra scripts (sorted for deterministic output)
	if len(extraScripts) > 0 {
		extraKeys := make([]string, 0, len(extraScripts))
		for k := range extraScripts {
			extraKeys = append(extraKeys, k)
		}
		sort.Strings(extraKeys)
		for _, k := range extraKeys {
			b.WriteString(",\n")
			fmt.Fprintf(&b, "    \"%s\": \"%s\"", k, extraScripts[k])
		}
	}
	b.WriteString("\n")
	b.WriteString("  },\n")

	writeSortedDeps := func(label string, m map[string]string) {
		b.WriteString(fmt.Sprintf("  \"%s\": {\n", label))
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			fmt.Fprintf(&b, "    \"%s\": \"%s\"", k, m[k])
			if i < len(keys)-1 {
				b.WriteString(",")
			}
			b.WriteString("\n")
		}
		b.WriteString("  }")
	}

	writeSortedDeps("dependencies", deps)
	b.WriteString(",\n")
	writeSortedDeps("devDependencies", devDeps)
	b.WriteString("\n")
	b.WriteString("}\n")

	return b.String()
}
