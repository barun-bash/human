package node

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateErrorHandler produces Express error handling middleware from IR ErrorHandlers.
func generateErrorHandler(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler â€” do not edit\n\n")
	b.WriteString("import { Request, Response, NextFunction } from 'express';\n\n")

	// Write handler configs from IR error handlers
	if len(app.ErrorHandlers) > 0 {
		b.WriteString("// Error handler configuration derived from .human file\n")
		b.WriteString("const errorHandlers: Array<{\n")
		b.WriteString("  condition: string;\n")
		b.WriteString("  retries?: number;\n")
		b.WriteString("  delayMs?: number;\n")
		b.WriteString("  alert?: string;\n")
		b.WriteString("}> = [\n")

		for _, eh := range app.ErrorHandlers {
			retries, delay := extractRetryConfig(eh)
			alertTarget := extractAlertTarget(eh)

			b.WriteString("  {\n")
			fmt.Fprintf(&b, "    condition: '%s',\n", escapeQuote(eh.Condition))
			if retries > 0 {
				fmt.Fprintf(&b, "    retries: %d,\n", retries)
				fmt.Fprintf(&b, "    delayMs: %d,\n", delay)
			}
			if alertTarget != "" {
				fmt.Fprintf(&b, "    alert: '%s',\n", escapeQuote(alertTarget))
			}
			b.WriteString("  },\n")
		}

		b.WriteString("];\n\n")
	}

	// sleep helper for retry delays
	b.WriteString("function sleep(ms: number): Promise<void> {\n")
	b.WriteString("  return new Promise(resolve => setTimeout(resolve, ms));\n")
	b.WriteString("}\n\n")

	// Main error handler middleware
	b.WriteString(`export function errorHandler(err: Error, req: Request, res: Response, _next: NextFunction) {
  console.error('[Error]', err.message);

  // Database connection errors
  if (err.message.includes('connect') || err.message.includes('ECONNREFUSED')) {
    return res.status(503).json({
      error: 'Service temporarily unavailable. Please try again.',
    });
  }

  // Validation errors
  if (err.name === 'ValidationError' || err.message.includes('validation')) {
    return res.status(400).json({
      error: err.message,
    });
  }

  // Default server error
  return res.status(500).json({
    error: 'An unexpected error occurred. Please try again later.',
  });
}
`)

	// Retry wrapper utility
	b.WriteString(`
export async function withRetry<T>(
  fn: () => Promise<T>,
  retries: number = 3,
  delayMs: number = 1000,
): Promise<T> {
  let lastError: Error | undefined;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err instanceof Error ? err : new Error(String(err));
      if (attempt < retries) {
        await sleep(delayMs);
      }
    }
  }
  throw lastError;
}
`)

	return b.String()
}

// extractRetryConfig looks for retry steps in an error handler.
// Returns (retries, delayMs).
func extractRetryConfig(eh *ir.ErrorHandler) (int, int) {
	for _, step := range eh.Steps {
		if step.Type != "retry" {
			continue
		}
		lower := strings.ToLower(step.Text)

		retries := 3
		delayMs := 1000

		// Parse "retry 3 times with 1 second delay"
		if idx := strings.Index(lower, "retry "); idx != -1 {
			after := lower[idx+len("retry "):]
			var n int
			if _, err := fmt.Sscanf(after, "%d", &n); err == nil && n > 0 {
				retries = n
			}
		}

		if strings.Contains(lower, "1 second") {
			delayMs = 1000
		} else if strings.Contains(lower, "2 second") {
			delayMs = 2000
		} else if strings.Contains(lower, "5 second") {
			delayMs = 5000
		}

		return retries, delayMs
	}
	return 0, 0
}

// extractAlertTarget looks for alert steps and returns the alert target.
func extractAlertTarget(eh *ir.ErrorHandler) string {
	for _, step := range eh.Steps {
		if step.Type != "alert" {
			continue
		}
		// "alert the engineering team via Slack"
		text := step.Text
		if idx := strings.Index(strings.ToLower(text), "alert "); idx != -1 {
			return strings.TrimSpace(text[idx+len("alert "):])
		}
		return text
	}
	return ""
}

// escapeQuote escapes single quotes for JS string literals.
func escapeQuote(s string) string {
	return strings.ReplaceAll(s, "'", "\\'")
}
