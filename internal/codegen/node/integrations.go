package node

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateIntegrations returns a map of file paths (relative to outputDir) to
// their generated TypeScript content for all integration services.
func generateIntegrations(app *ir.Application) map[string]string {
	if len(app.Integrations) == 0 {
		return nil
	}

	files := make(map[string]string)
	var exports []string
	usedFilenames := make(map[string]bool)

	for _, integ := range app.Integrations {
		var content string
		var filename string

		switch integ.Type {
		case "email":
			filename = "email.ts"
			content = generateEmailService(integ)
		case "storage":
			filename = "storage.ts"
			content = generateStorageService(integ)
		case "payment":
			filename = "stripe.ts"
			content = generatePaymentService(integ)
		case "messaging":
			filename = "slack.ts"
			content = generateMessagingService(integ)
		case "oauth":
			filename = "oauth.ts"
			content = generateOAuthService(integ)
		default:
			filename = toKebabCase(integ.Service) + ".ts"
			content = generateGenericService(integ)
		}

		// If filename is already used (two integrations of same type),
		// fall back to a service-specific filename.
		if usedFilenames[filename] {
			filename = toKebabCase(integ.Service) + ".ts"
		}
		usedFilenames[filename] = true

		files["src/services/"+filename] = content
		exports = append(exports, filename)
	}

	// Generate barrel export.
	files["src/services/index.ts"] = generateServiceIndex(exports)

	return files
}

// generateEmailService produces a TypeScript email service using SendGrid / nodemailer.
func generateEmailService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s (email)\n\n", integ.Service)

	// Determine the API key env var.
	apiKeyEnv := "SENDGRID_API_KEY"
	for _, envVar := range integ.Credentials {
		apiKeyEnv = envVar
		break
	}

	b.WriteString(`import sgMail from "@sendgrid/mail";

`)
	fmt.Fprintf(&b, "sgMail.setApiKey(process.env.%s || \"\");\n\n", apiKeyEnv)

	// Sender email.
	senderEmail := "noreply@example.com"
	if v, ok := integ.Config["sender_email"]; ok {
		senderEmail = v
	}

	b.WriteString("export interface SendEmailOptions {\n")
	b.WriteString("  to: string;\n")
	b.WriteString("  subject: string;\n")
	b.WriteString("  text?: string;\n")
	b.WriteString("  html?: string;\n")
	b.WriteString("  template?: string;\n")
	b.WriteString("  templateData?: Record<string, unknown>;\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function sendEmail(options: SendEmailOptions): Promise<void> {\n")
	b.WriteString("  const msg = {\n")
	fmt.Fprintf(&b, "    from: \"%s\",\n", senderEmail)
	b.WriteString("    to: options.to,\n")
	b.WriteString("    subject: options.subject,\n")
	b.WriteString("    ...(options.text && { text: options.text }),\n")
	b.WriteString("    ...(options.html && { html: options.html }),\n")
	b.WriteString("    ...(options.template && {\n")
	b.WriteString("      templateId: options.template,\n")
	b.WriteString("      dynamicTemplateData: options.templateData,\n")
	b.WriteString("    }),\n")
	b.WriteString("  };\n\n")
	b.WriteString("  await sgMail.send(msg);\n")
	b.WriteString("}\n")

	// Generate template helpers if templates are defined.
	if len(integ.Templates) > 0 {
		b.WriteString("\n// Available email templates\n")
		b.WriteString("export const EMAIL_TEMPLATES = {\n")
		for _, tpl := range integ.Templates {
			constName := strings.ReplaceAll(strings.ToUpper(tpl), "-", "_")
			fmt.Fprintf(&b, "  %s: \"%s\",\n", constName, tpl)
		}
		b.WriteString("} as const;\n")
	}

	return b.String()
}

// generateStorageService produces a TypeScript storage service using AWS S3.
func generateStorageService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s (storage)\n\n", integ.Service)

	// Determine env vars.
	accessKeyEnv := "AWS_ACCESS_KEY"
	secretKeyEnv := "AWS_SECRET_KEY"
	for key, envVar := range integ.Credentials {
		lower := strings.ToLower(key)
		if strings.Contains(lower, "secret") {
			secretKeyEnv = envVar
		} else {
			accessKeyEnv = envVar
		}
	}

	region := "us-east-1"
	if v, ok := integ.Config["region"]; ok {
		region = v
	}

	bucket := strings.ToLower(strings.ReplaceAll(integ.Service, " ", "-")) + "-bucket"
	if v, ok := integ.Config["bucket"]; ok {
		bucket = v
	}

	b.WriteString(`import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

`)
	b.WriteString("const s3 = new S3Client({\n")
	fmt.Fprintf(&b, "  region: process.env.AWS_REGION || \"%s\",\n", region)
	b.WriteString("  credentials: {\n")
	fmt.Fprintf(&b, "    accessKeyId: process.env.%s || \"\",\n", accessKeyEnv)
	fmt.Fprintf(&b, "    secretAccessKey: process.env.%s || \"\",\n", secretKeyEnv)
	b.WriteString("  },\n")
	b.WriteString("});\n\n")

	fmt.Fprintf(&b, "const BUCKET = process.env.S3_BUCKET || \"%s\";\n\n", bucket)

	b.WriteString("export async function uploadFile(key: string, body: Buffer, contentType?: string): Promise<string> {\n")
	b.WriteString("  await s3.send(new PutObjectCommand({\n")
	b.WriteString("    Bucket: BUCKET,\n")
	b.WriteString("    Key: key,\n")
	b.WriteString("    Body: body,\n")
	b.WriteString("    ...(contentType && { ContentType: contentType }),\n")
	b.WriteString("  }));\n")
	b.WriteString("  return key;\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function getSignedDownloadUrl(key: string, expiresIn = 3600): Promise<string> {\n")
	b.WriteString("  const command = new GetObjectCommand({ Bucket: BUCKET, Key: key });\n")
	b.WriteString("  return getSignedUrl(s3, command, { expiresIn });\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function deleteFile(key: string): Promise<void> {\n")
	b.WriteString("  await s3.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }));\n")
	b.WriteString("}\n")

	return b.String()
}

// generatePaymentService produces a TypeScript payment service using Stripe.
func generatePaymentService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s (payment)\n\n", integ.Service)

	apiKeyEnv := "STRIPE_SECRET_KEY"
	for _, envVar := range integ.Credentials {
		apiKeyEnv = envVar
		break
	}

	b.WriteString(`import Stripe from "stripe";

`)
	fmt.Fprintf(&b, "const stripe = new Stripe(process.env.%s || \"\", { apiVersion: \"2024-06-20\" });\n\n", apiKeyEnv)

	b.WriteString("export interface CreateCheckoutOptions {\n")
	b.WriteString("  priceId: string;\n")
	b.WriteString("  customerId?: string;\n")
	b.WriteString("  successUrl: string;\n")
	b.WriteString("  cancelUrl: string;\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function createCheckoutSession(options: CreateCheckoutOptions): Promise<Stripe.Checkout.Session> {\n")
	b.WriteString("  return stripe.checkout.sessions.create({\n")
	b.WriteString("    mode: \"payment\",\n")
	b.WriteString("    line_items: [{ price: options.priceId, quantity: 1 }],\n")
	b.WriteString("    ...(options.customerId && { customer: options.customerId }),\n")
	b.WriteString("    success_url: options.successUrl,\n")
	b.WriteString("    cancel_url: options.cancelUrl,\n")
	b.WriteString("  });\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function createCustomer(email: string, name?: string): Promise<Stripe.Customer> {\n")
	b.WriteString("  return stripe.customers.create({ email, ...(name && { name }) });\n")
	b.WriteString("}\n\n")

	// Webhook verification if endpoint is configured.
	if webhookEndpoint, ok := integ.Config["webhook_endpoint"]; ok {
		b.WriteString("export function verifyWebhookSignature(\n")
		b.WriteString("  payload: string | Buffer,\n")
		b.WriteString("  signature: string,\n")
		b.WriteString("  secret: string,\n")
		b.WriteString("): Stripe.Event {\n")
		b.WriteString("  return stripe.webhooks.constructEvent(payload, signature, secret);\n")
		b.WriteString("}\n\n")
		fmt.Fprintf(&b, "export const WEBHOOK_ENDPOINT = \"%s\";\n", webhookEndpoint)
	}

	return b.String()
}

// generateMessagingService produces a TypeScript messaging service using Slack webhooks.
func generateMessagingService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s (messaging)\n\n", integ.Service)

	webhookEnv := "SLACK_WEBHOOK_URL"
	for _, envVar := range integ.Credentials {
		webhookEnv = envVar
		break
	}

	b.WriteString(`import { IncomingWebhook } from "@slack/webhook";

`)
	fmt.Fprintf(&b, "const webhook = new IncomingWebhook(process.env.%s || \"\");\n\n", webhookEnv)

	channel := ""
	if v, ok := integ.Config["channel"]; ok {
		channel = v
	}

	b.WriteString("export interface SlackMessageOptions {\n")
	b.WriteString("  text: string;\n")
	b.WriteString("  channel?: string;\n")
	b.WriteString("  username?: string;\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function sendSlackMessage(options: SlackMessageOptions): Promise<void> {\n")
	b.WriteString("  await webhook.send({\n")
	b.WriteString("    text: options.text,\n")
	if channel != "" {
		fmt.Fprintf(&b, "    channel: options.channel || \"%s\",\n", channel)
	} else {
		b.WriteString("    ...(options.channel && { channel: options.channel }),\n")
	}
	b.WriteString("    ...(options.username && { username: options.username }),\n")
	b.WriteString("  });\n")
	b.WriteString("}\n\n")

	b.WriteString("export async function sendAlert(message: string): Promise<void> {\n")
	b.WriteString("  await sendSlackMessage({ text: `:warning: ${message}` });\n")
	b.WriteString("}\n")

	return b.String()
}

// generateOAuthService produces a TypeScript OAuth service using Passport.js.
func generateOAuthService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s (oauth)\n\n", integ.Service)

	serviceLower := strings.ToLower(integ.Service)

	// Determine credential env vars.
	clientIDEnv := strings.ToUpper(strings.ReplaceAll(integ.Service, " ", "_")) + "_CLIENT_ID"
	clientSecretEnv := strings.ToUpper(strings.ReplaceAll(integ.Service, " ", "_")) + "_CLIENT_SECRET"
	for key, envVar := range integ.Credentials {
		lower := strings.ToLower(key)
		if strings.Contains(lower, "secret") {
			clientSecretEnv = envVar
		} else if strings.Contains(lower, "id") || strings.Contains(lower, "client") {
			clientIDEnv = envVar
		}
	}

	// Select the right passport strategy.
	strategyPkg := "passport-google-oauth20"
	strategyName := "GoogleStrategy"
	passportName := "google"
	if strings.Contains(serviceLower, "github") {
		strategyPkg = "passport-github2"
		strategyName = "GitHubStrategy"
		passportName = "github"
	} else if strings.Contains(serviceLower, "facebook") {
		strategyPkg = "passport-facebook"
		strategyName = "FacebookStrategy"
		passportName = "facebook"
	}

	b.WriteString("import passport from \"passport\";\n")
	fmt.Fprintf(&b, "import { Strategy as %s } from \"%s\";\n\n", strategyName, strategyPkg)

	b.WriteString("export interface OAuthProfile {\n")
	b.WriteString("  id: string;\n")
	b.WriteString("  email: string;\n")
	b.WriteString("  displayName: string;\n")
	b.WriteString("  provider: string;\n")
	b.WriteString("}\n\n")

	fmt.Fprintf(&b, "export function configure%sAuth(callbackURL: string): void {\n", integ.Service)
	fmt.Fprintf(&b, "  passport.use(new %s(\n", strategyName)
	b.WriteString("    {\n")
	fmt.Fprintf(&b, "      clientID: process.env.%s || \"\",\n", clientIDEnv)
	fmt.Fprintf(&b, "      clientSecret: process.env.%s || \"\",\n", clientSecretEnv)
	b.WriteString("      callbackURL,\n")
	b.WriteString("    },\n")
	b.WriteString("    (_accessToken: string, _refreshToken: string, profile: any, done: any) => {\n")
	b.WriteString("      const user: OAuthProfile = {\n")
	b.WriteString("        id: profile.id,\n")
	b.WriteString("        email: profile.emails?.[0]?.value || \"\",\n")
	b.WriteString("        displayName: profile.displayName || \"\",\n")
	fmt.Fprintf(&b, "        provider: \"%s\",\n", passportName)
	b.WriteString("      };\n")
	b.WriteString("      done(null, user);\n")
	b.WriteString("    },\n")
	b.WriteString("  ));\n")
	b.WriteString("}\n")

	return b.String()
}

// generateGenericService produces a minimal TypeScript service for unknown integrations.
func generateGenericService(integ *ir.Integration) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n")
	fmt.Fprintf(&b, "// Integration: %s\n\n", integ.Service)

	if len(integ.Credentials) > 0 {
		b.WriteString("// Environment variables required:\n")
		for key, envVar := range integ.Credentials {
			fmt.Fprintf(&b, "//   %s: process.env.%s\n", key, envVar)
		}
		b.WriteString("\n")
	}

	b.WriteString("export const config = {\n")
	fmt.Fprintf(&b, "  service: \"%s\",\n", integ.Service)
	if integ.Purpose != "" {
		fmt.Fprintf(&b, "  purpose: \"%s\",\n", integ.Purpose)
	}
	for key, envVar := range integ.Credentials {
		safeKey := strings.ReplaceAll(key, " ", "_")
		fmt.Fprintf(&b, "  %s: process.env.%s || \"\",\n", safeKey, envVar)
	}
	b.WriteString("} as const;\n")

	return b.String()
}

// generateServiceIndex produces a barrel export for all service files.
func generateServiceIndex(filenames []string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	for _, f := range filenames {
		module := strings.TrimSuffix(f, ".ts")
		fmt.Fprintf(&b, "export * from \"./%s\";\n", module)
	}
	return b.String()
}
