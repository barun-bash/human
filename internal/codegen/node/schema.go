package node

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generatePrismaSchema produces a complete schema.prisma file from IR data models.
func generatePrismaSchema(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler â€” do not edit\n\n")

	// Datasource
	engine := "postgresql"
	if app.Database != nil && app.Database.Engine != "" {
		engine = strings.ToLower(app.Database.Engine)
		if strings.Contains(engine, "postgres") {
			engine = "postgresql"
		} else if strings.Contains(engine, "mysql") {
			engine = "mysql"
		} else if strings.Contains(engine, "sqlite") {
			engine = "sqlite"
		}
	}

	fmt.Fprintf(&b, "datasource db {\n")
	fmt.Fprintf(&b, "  provider = \"%s\"\n", engine)
	b.WriteString("  url      = env(\"DATABASE_URL\")\n")
	b.WriteString("}\n\n")

	// Generator
	b.WriteString("generator client {\n")
	b.WriteString("  provider = \"prisma-client-js\"\n")
	b.WriteString("}\n")

	// Build index lookup for @@index directives
	indexMap := buildIndexMap(app)

	// Models
	for _, model := range app.Data {
		b.WriteString("\n")
		writePrismaModel(&b, model, app, indexMap)
	}

	return b.String()
}

// buildIndexMap groups database indexes by entity name.
func buildIndexMap(app *ir.Application) map[string][][]string {
	m := make(map[string][][]string)
	if app.Database == nil {
		return m
	}
	for _, idx := range app.Database.Indexes {
		m[idx.Entity] = append(m[idx.Entity], idx.Fields)
	}
	return m
}

// writePrismaModel writes a single Prisma model block.
func writePrismaModel(b *strings.Builder, model *ir.DataModel, app *ir.Application, indexMap map[string][][]string) {
	fmt.Fprintf(b, "model %s {\n", model.Name)

	// id field
	b.WriteString("  id        String   @id @default(cuid())\n")

	// Fields
	for _, f := range model.Fields {
		writePrismaField(b, f, model)
	}

	// Relation fields
	for _, rel := range model.Relations {
		writePrismaRelation(b, rel, model)
	}

	// Timestamp fields
	b.WriteString("  createdAt DateTime @default(now())\n")
	b.WriteString("  updatedAt DateTime @updatedAt\n")

	// Indexes from database config
	if indexes, ok := indexMap[model.Name]; ok {
		for _, fields := range indexes {
			sanitized := make([]string, len(fields))
			for i, f := range fields {
				sanitized[i] = toCamelCase(f)
			}
			fmt.Fprintf(b, "\n  @@index([%s])\n", strings.Join(sanitized, ", "))
		}
	}

	b.WriteString("}\n")
}

// writePrismaField writes a single field line in a Prisma model.
func writePrismaField(b *strings.Builder, f *ir.DataField, model *ir.DataModel) {
	// Skip fields that will be represented as Prisma timestamps
	lower := strings.ToLower(f.Name)
	if lower == "created" || lower == "createdat" || lower == "updated" || lower == "updatedat" {
		return
	}

	name := f.Name
	var pType string
	optional := ""
	attrs := []string{}

	if f.Type == "enum" && len(f.EnumValues) > 0 {
		// Use the enum name convention: ModelFieldName
		pType = model.Name + capitalize(f.Name)
	} else {
		pType = prismaType(f.Type)
	}

	if !f.Required {
		optional = "?"
	}

	if f.Unique {
		attrs = append(attrs, "@unique")
	}

	if f.Default != "" {
		attrs = append(attrs, fmt.Sprintf("@default(\"%s\")", f.Default))
	}

	line := fmt.Sprintf("  %-9s %s%s", name, pType, optional)
	if len(attrs) > 0 {
		line += " " + strings.Join(attrs, " ")
	}
	b.WriteString(line + "\n")
}

// writePrismaRelation writes relation fields for a Prisma model.
func writePrismaRelation(b *strings.Builder, rel *ir.Relation, model *ir.DataModel) {
	switch rel.Kind {
	case "belongs_to":
		// Foreign key + relation
		fkName := toCamelCase(rel.Target) + "Id"
		relName := toCamelCase(rel.Target)
		fmt.Fprintf(b, "  %-9s String\n", fkName)
		fmt.Fprintf(b, "  %-9s %s    @relation(fields: [%s], references: [id])\n", relName, rel.Target, fkName)

	case "has_many":
		relName := toCamelCase(rel.Target) + "s"
		fmt.Fprintf(b, "  %-9s %s[]\n", relName, rel.Target)

	case "has_many_through":
		// Through table: reference the join model
		relName := toCamelCase(rel.Through) + "s"
		fmt.Fprintf(b, "  %-9s %s[]\n", relName, rel.Through)
	}
}

// capitalize returns the string with its first letter uppercased.
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
