package node

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generatePrismaSchema produces a complete schema.prisma file from IR data models.
func generatePrismaSchema(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	// Datasource
	engine := "postgresql"
	if app.Database != nil && app.Database.Engine != "" {
		engine = strings.ToLower(app.Database.Engine)
		if strings.Contains(engine, "postgres") {
			engine = "postgresql"
		} else if strings.Contains(engine, "mysql") {
			engine = "mysql"
		} else if strings.Contains(engine, "sqlite") {
			engine = "sqlite"
		}
	}

	fmt.Fprintf(&b, "datasource db {\n")
	fmt.Fprintf(&b, "  provider = \"%s\"\n", engine)
	b.WriteString("  url      = env(\"DATABASE_URL\")\n")
	b.WriteString("}\n\n")

	// Generator
	b.WriteString("generator client {\n")
	b.WriteString("  provider = \"prisma-client-js\"\n")
	b.WriteString("}\n")

	// Build index lookup for @@index directives
	indexMap := buildIndexMap(app)

	// Models
	for _, model := range app.Data {
		b.WriteString("\n")
		writePrismaModel(&b, model, app, indexMap)
	}

	// Enum blocks — collect from all models and emit after models
	writePrismaEnums(&b, app)

	return b.String()
}

// buildIndexMap groups database indexes by entity name.
func buildIndexMap(app *ir.Application) map[string][][]string {
	m := make(map[string][][]string)
	if app.Database == nil {
		return m
	}
	for _, idx := range app.Database.Indexes {
		m[idx.Entity] = append(m[idx.Entity], idx.Fields)
	}
	return m
}

// writePrismaModel writes a single Prisma model block.
func writePrismaModel(b *strings.Builder, model *ir.DataModel, app *ir.Application, indexMap map[string][][]string) {
	fmt.Fprintf(b, "model %s {\n", model.Name)

	// id field
	b.WriteString("  id        String   @id @default(cuid())\n")

	// Fields
	for _, f := range model.Fields {
		writePrismaField(b, f, model)
	}

	// Relation fields
	for _, rel := range model.Relations {
		writePrismaRelation(b, rel, model)
	}

	// Reverse relation fields: if another model has belongs_to pointing here,
	// Prisma requires the inverse has_many side to be declared.
	for _, other := range app.Data {
		if other.Name == model.Name {
			continue
		}
		for _, rel := range other.Relations {
			if rel.Kind == "belongs_to" && rel.Target == model.Name {
				// Check this model doesn't already declare this relation
				alreadyDeclared := false
				for _, ownRel := range model.Relations {
					if (ownRel.Kind == "has_many" || ownRel.Kind == "has_one") && ownRel.Target == other.Name {
						alreadyDeclared = true
						break
					}
				}
				if !alreadyDeclared {
					relName := toCamelCase(other.Name) + "s"
					fmt.Fprintf(b, "  %-9s %s[]\n", relName, other.Name)
				}
			}
		}
	}

	// Timestamp fields
	b.WriteString("  createdAt DateTime @default(now())\n")
	b.WriteString("  updatedAt DateTime @updatedAt\n")

	// Indexes from database config
	if indexes, ok := indexMap[model.Name]; ok {
		for _, fields := range indexes {
			resolved := make([]string, len(fields))
			for i, f := range fields {
				resolved[i] = resolvePrismaFieldName(f, model)
			}
			fmt.Fprintf(b, "\n  @@index([%s])\n", strings.Join(resolved, ", "))
		}
	}

	b.WriteString("}\n")
}

// writePrismaField writes a single field line in a Prisma model.
func writePrismaField(b *strings.Builder, f *ir.DataField, model *ir.DataModel) {
	// Skip fields that will be represented as Prisma timestamps
	lower := strings.ToLower(f.Name)
	if lower == "created" || lower == "createdat" || lower == "updated" || lower == "updatedat" {
		return
	}

	name := f.Name
	var pType string
	optional := ""
	attrs := []string{}

	if f.Type == "enum" && len(f.EnumValues) > 0 {
		// Use the enum name convention: ModelFieldName
		pType = model.Name + capitalize(f.Name)
	} else {
		pType = prismaType(f.Type)
	}

	if !f.Required {
		optional = "?"
	}

	if f.Unique {
		attrs = append(attrs, "@unique")
	}

	if f.Default != "" {
		attrs = append(attrs, fmt.Sprintf("@default(\"%s\")", f.Default))
	}

	line := fmt.Sprintf("  %-9s %s%s", name, pType, optional)
	if len(attrs) > 0 {
		line += " " + strings.Join(attrs, " ")
	}
	b.WriteString(line + "\n")
}

// writePrismaRelation writes relation fields for a Prisma model.
func writePrismaRelation(b *strings.Builder, rel *ir.Relation, model *ir.DataModel) {
	switch rel.Kind {
	case "belongs_to":
		// Foreign key + relation
		fkName := toCamelCase(rel.Target) + "Id"
		relName := toCamelCase(rel.Target)
		fmt.Fprintf(b, "  %-9s String\n", fkName)
		fmt.Fprintf(b, "  %-9s %s    @relation(fields: [%s], references: [id])\n", relName, rel.Target, fkName)

	case "has_many":
		relName := toCamelCase(rel.Target) + "s"
		fmt.Fprintf(b, "  %-9s %s[]\n", relName, rel.Target)

	case "has_many_through":
		// Through table: reference the join model
		relName := toCamelCase(rel.Through) + "s"
		fmt.Fprintf(b, "  %-9s %s[]\n", relName, rel.Through)
	}
}

// resolvePrismaFieldName maps an IR index field name to the actual Prisma field
// name in the given model. It handles:
//   - Relation fields (belongs_to) → scalar FK name (e.g., "user" → "userId")
//   - Compound names where the type is appended (e.g., "due date" → "due")
//   - Direct field name matches
func resolvePrismaFieldName(fieldName string, model *ir.DataModel) string {
	lower := strings.ToLower(strings.TrimSpace(fieldName))

	// Check relations first: belongs_to target → FK scalar field
	for _, rel := range model.Relations {
		if rel.Kind == "belongs_to" {
			if strings.EqualFold(rel.Target, fieldName) || strings.ToLower(toCamelCase(rel.Target)) == lower {
				return toCamelCase(rel.Target) + "Id"
			}
		}
	}

	// Direct match on field name
	for _, f := range model.Fields {
		if strings.EqualFold(f.Name, fieldName) {
			return f.Name
		}
	}

	// Match field name + type (e.g., "due date" where field is "due" with type "date")
	for _, f := range model.Fields {
		nameAndType := f.Name + " " + f.Type
		if strings.EqualFold(nameAndType, fieldName) {
			return f.Name
		}
	}

	// Fallback: camelCase the raw name
	return toCamelCase(fieldName)
}

// writePrismaEnums collects enum fields from all models and writes enum blocks.
func writePrismaEnums(b *strings.Builder, app *ir.Application) {
	for _, model := range app.Data {
		for _, f := range model.Fields {
			if f.Type == "enum" && len(f.EnumValues) > 0 {
				enumName := model.Name + capitalize(f.Name)
				b.WriteString("\n")
				fmt.Fprintf(b, "enum %s {\n", enumName)
				for _, v := range f.EnumValues {
					fmt.Fprintf(b, "  %s\n", v)
				}
				b.WriteString("}\n")
			}
		}
	}
}

// capitalize returns the string with its first letter uppercased.
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
