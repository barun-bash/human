package node

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateRouteIndex produces src/routes/index.ts that registers all routes.
func generateRouteIndex(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { Router } from 'express';\n")

	// Import each route handler
	for _, ep := range app.APIs {
		varName := toCamelCase(ep.Name) + "Router"
		fileName := toKebabCase(ep.Name)
		fmt.Fprintf(&b, "import { router as %s } from './%s';\n", varName, fileName)
	}

	b.WriteString("\nconst router = Router();\n\n")

	// Mount each route
	for _, ep := range app.APIs {
		varName := toCamelCase(ep.Name) + "Router"
		path := routePath(ep.Name)
		fmt.Fprintf(&b, "router.use('%s', %s);\n", path, varName)
	}

	b.WriteString("\nexport { router };\n")

	return b.String()
}

// generateRoute produces a single Express route file for an endpoint.
func generateRoute(ep *ir.Endpoint, app *ir.Application) string {
	var b strings.Builder

	isSignUp := isSignUpEndpoint(ep.Name)
	isLogin := isLoginEndpoint(ep.Name)
	needsBcrypt := isSignUp || isLogin
	needsSignToken := isSignUp || isLogin

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { Router, Request, Response, NextFunction } from 'express';\n")
	b.WriteString("import { PrismaClient } from '@prisma/client';\n")

	if ep.Auth {
		b.WriteString("import { authenticate } from '../middleware/auth';\n")
	}

	// Import authorize when policies exist and endpoint has auth
	action := inferRouteAction(ep.Name)
	model := inferRouteModel(ep.Name)
	useAuthorize := len(app.Policies) > 0 && ep.Auth && action != "" && model != ""
	if useAuthorize {
		b.WriteString("import { authorize } from '../middleware/authorize';\n")
	}

	if needsBcrypt {
		b.WriteString("import bcrypt from 'bcryptjs';\n")
	}
	if needsSignToken {
		b.WriteString("import { signToken } from '../middleware/auth';\n")
	}

	b.WriteString("\nconst prisma = new PrismaClient();\n")
	b.WriteString("const router = Router();\n\n")

	method := httpMethod(ep.Name)

	// Build middleware chain
	middlewares := []string{}
	if ep.Auth {
		middlewares = append(middlewares, "authenticate")
	}
	if useAuthorize {
		middlewares = append(middlewares, fmt.Sprintf("authorize('%s', '%s')", action, model))
	}

	// Route handler
	if len(middlewares) > 0 {
		fmt.Fprintf(&b, "router.%s('/',\n  %s,\n  async (req: Request, res: Response, next: NextFunction) => {\n",
			method, strings.Join(middlewares, ",\n  "))
	} else {
		fmt.Fprintf(&b, "router.%s('/', async (req: Request, res: Response, next: NextFunction) => {\n", method)
	}

	b.WriteString("  try {\n")

	// Extract params — use 'let' if any step reassigns a destructured variable
	hasDefaultAssign := false
	for _, step := range ep.Steps {
		if isDefaultAssignment(step.Text) {
			hasDefaultAssign = true
			break
		}
	}
	if len(ep.Params) > 0 {
		paramNames := make([]string, len(ep.Params))
		for i, p := range ep.Params {
			paramNames[i] = sanitizeParamName(p.Name)
		}
		binding := "const"
		if hasDefaultAssign {
			binding = "let"
		}
		if method == "get" || method == "delete" {
			fmt.Fprintf(&b, "    %s { %s } = req.query as Record<string, string>;\n", binding, strings.Join(paramNames, ", "))
		} else {
			fmt.Fprintf(&b, "    %s { %s } = req.body;\n", binding, strings.Join(paramNames, ", "))
		}
		b.WriteString("\n")
	}

	// Validation rules
	if len(ep.Validation) > 0 {
		b.WriteString("    // Validation\n")
		for _, v := range ep.Validation {
			writeValidationCheck(&b, v, ep, app)
		}
		b.WriteString("\n")
	}

	// Special-case Login: emit hand-crafted auth logic instead of generic steps
	if isLogin {
		writeLoginBody(&b, ep, app)
	} else {
		// Steps as comments with skeleton code
		resultIdx := 0
		for _, step := range ep.Steps {
			writeStepCode(&b, step, ep, app, &resultIdx, isSignUp)
		}
	}

	b.WriteString("  } catch (error) {\n")
	b.WriteString("    next(error);\n")
	b.WriteString("  }\n")

	b.WriteString("});\n")

	b.WriteString("\nexport { router };\n")

	return b.String()
}

// writeLoginBody emits the complete Login route body with proper auth logic.
func writeLoginBody(b *strings.Builder, ep *ir.Endpoint, app *ir.Application) {
	// Infer the user model from steps or default to "user"
	loginModel := "user"
	for _, step := range ep.Steps {
		m := inferModelFromAction(step.Text, app)
		if !strings.EqualFold(m, "Record") {
			loginModel = toCamelCase(m)
			break
		}
	}

	fmt.Fprintf(b, "    // fetch the user by email\n")
	fmt.Fprintf(b, "    const user = await prisma.%s.findUnique({ where: { email } });\n\n", loginModel)

	b.WriteString("    // if user does not exist, respond with invalid credentials\n")
	b.WriteString("    if (!user) {\n")
	b.WriteString("      return res.status(401).json({ error: 'Invalid credentials' });\n")
	b.WriteString("    }\n\n")

	b.WriteString("    // if password does not match, respond with invalid credentials\n")
	b.WriteString("    const valid = await bcrypt.compare(password, user.password);\n")
	b.WriteString("    if (!valid) {\n")
	b.WriteString("      return res.status(401).json({ error: 'Invalid credentials' });\n")
	b.WriteString("    }\n\n")

	b.WriteString("    // respond with the user and auth token\n")
	b.WriteString("    const token = signToken(user.id, user.role);\n")
	b.WriteString("    return res.json({ data: user, token });\n\n")
}

// writeValidationCheck writes a validation guard for a single rule.
func writeValidationCheck(b *strings.Builder, v *ir.ValidationRule, ep *ir.Endpoint, app *ir.Application) {
	field := sanitizeParamName(v.Field)

	switch v.Rule {
	case "not_empty":
		fmt.Fprintf(b, "    if (!%s || %s.trim() === '') {\n", field, field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s is required' });\n", v.Field)
		b.WriteString("    }\n")

	case "valid_email":
		fmt.Fprintf(b, "    if (!%s || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(%s)) {\n", field, field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: 'Invalid email address' });\n")
		b.WriteString("    }\n")

	case "min_length":
		fmt.Fprintf(b, "    if (!%s || %s.length < %s) {\n", field, field, v.Value)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be at least %s characters' });\n", v.Field, v.Value)
		b.WriteString("    }\n")

	case "max_length":
		fmt.Fprintf(b, "    if (%s && %s.length > %s) {\n", field, field, v.Value)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be less than %s characters' });\n", v.Field, v.Value)
		b.WriteString("    }\n")

	case "unique":
		modelName := inferModelFromEndpointWithApp(field, app)
		fmt.Fprintf(b, "    const existing = await prisma.%s.findUnique({ where: { %s } });\n", modelName, field)
		b.WriteString("    if (existing) {\n")
		fmt.Fprintf(b, "      return res.status(409).json({ error: '%s is already taken' });\n", v.Field)
		b.WriteString("    }\n")

	case "future_date":
		fmt.Fprintf(b, "    if (new Date(%s) <= new Date()) {\n", field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be in the future' });\n", v.Field)
		b.WriteString("    }\n")

	case "matches":
		fmt.Fprintf(b, "    // TODO: validate that %s matches expected pattern\n", v.Field)

	case "authorization":
		fmt.Fprintf(b, "    // Authorization: current user %s\n", v.Value)
		lower := strings.ToLower(v.Value)
		if strings.Contains(lower, "owner") || strings.Contains(lower, "their own") {
			// Infer model from the endpoint name for the ownership query
			authzModel := inferRouteModel(ep.Name)
			if authzModel == "" {
				authzModel = "record"
			}
			idExpr := findIdParam(ep)
			if idExpr == "" {
				idExpr = "req.body.id"
			}
			b.WriteString("    if (req.userRole !== 'Admin' && req.authzScope === 'own') {\n")
			fmt.Fprintf(b, "      // Ownership check — verify %s belongs to the current user\n", authzModel)
			fmt.Fprintf(b, "      const resource = await prisma.%s.findUnique({ where: { id: %s } });\n", authzModel, idExpr)
			b.WriteString("      const ownerId = (resource as any)?.userId ?? (resource as any)?.user_id;\n")
			b.WriteString("      if (!resource || (ownerId && ownerId !== req.userId)) {\n")
			b.WriteString("        return res.status(403).json({ error: 'You can only access your own resources' });\n")
			b.WriteString("      }\n")
			b.WriteString("    }\n")
		} else {
			// Generic role-based check
			b.WriteString("    // Role-based authorization enforced by authorize() middleware\n")
		}
	}
}

// writeStepCode writes handler code for a single action step.
func writeStepCode(b *strings.Builder, step *ir.Action, ep *ir.Endpoint, app *ir.Application, resultIdx *int, isSignUp bool) {
	switch step.Type {
	case "create":
		model := inferModelFromAction(step.Text, app)
		modelCamel := toCamelCase(model)
		targetModel := findModel(model, app)

		varName := resultVarName(resultIdx)
		fmt.Fprintf(b, "    // %s\n", step.Text)

		// SignUp: hash password before creating
		if isSignUp {
			b.WriteString("    const hashedPassword = await bcrypt.hash(password, 12);\n")
		}

		fmt.Fprintf(b, "    %s = await prisma.%s.create({\n", varName, modelCamel)
		b.WriteString("      data: {\n")
		for _, p := range ep.Params {
			paramSanitized := sanitizeParamName(p.Name)

			// For SignUp, replace password with hashedPassword
			if isSignUp && strings.ToLower(p.Name) == "password" {
				fmt.Fprintf(b, "        password: hashedPassword,\n")
				continue
			}

			// Map param name to Prisma field name
			prismaField, paramRef := mapParamToPrismaField(p.Name, targetModel)
			if prismaField != paramRef {
				fmt.Fprintf(b, "        %s: %s,\n", prismaField, paramRef)
			} else {
				fmt.Fprintf(b, "        %s,\n", paramSanitized)
			}
		}
		// Add userId for authenticated endpoints where model belongs_to User
		if ep.Auth && modelBelongsToUser(model, app) {
			b.WriteString("        userId: req.userId!,\n")
		}
		// Add required enum fields that aren't in params (with first enum value as default)
		if targetModel != nil {
			paramSet := map[string]bool{}
			for _, p := range ep.Params {
				paramSet[strings.ToLower(p.Name)] = true
			}
			for _, f := range targetModel.Fields {
				if f.Type == "enum" && f.Required && len(f.EnumValues) > 0 && !paramSet[strings.ToLower(f.Name)] {
					fmt.Fprintf(b, "        %s: '%s',\n", f.Name, f.EnumValues[0])
				}
			}
		}
		b.WriteString("      },\n")
		b.WriteString("    });\n\n")

	case "query":
		// Skip query modifiers — emit as TODO comments only
		if isQueryModifier(step.Text) {
			fmt.Fprintf(b, "    // TODO: %s\n", step.Text)
			return
		}

		model := inferModelFromAction(step.Text, app)
		modelCamel := toCamelCase(model)
		varName := resultVarName(resultIdx)
		fmt.Fprintf(b, "    // %s\n", step.Text)

		// Check if this is a single-fetch ("fetch the X by Y") pattern
		if isSingleFetch(step.Text) {
			idParam := findIdParam(ep)
			if idParam != "" {
				fmt.Fprintf(b, "    %s = await prisma.%s.findUnique({ where: { id: %s } });\n\n", varName, modelCamel, idParam)
			} else {
				fmt.Fprintf(b, "    %s = await prisma.%s.findUnique({ where: { id: req.body.id } });\n\n", varName, modelCamel)
			}
		} else if ep.Auth && modelBelongsToUser(model, app) {
			// Authenticated query on a model that belongs to User → scope by userId
			fmt.Fprintf(b, "    %s = await prisma.%s.findMany({ where: { userId: req.userId } });\n\n", varName, modelCamel)
		} else {
			fmt.Fprintf(b, "    %s = await prisma.%s.findMany();\n\n", varName, modelCamel)
		}

	case "update":
		// Check for "set X to Y if not provided" → default assignment, not DB update
		if isDefaultAssignment(step.Text) {
			field, value := parseDefaultAssignment(step.Text)
			fmt.Fprintf(b, "    // %s\n", step.Text)
			fmt.Fprintf(b, "    if (!%s) { %s = '%s'; }\n\n", field, field, value)
			return
		}

		model := inferModelFromAction(step.Text, app)
		modelCamel := toCamelCase(model)
		targetModel := findModel(model, app)

		idParam := findIdParam(ep)
		if idParam == "" {
			idParam = "req.body.id"
		}

		varName := resultVarName(resultIdx)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    %s = await prisma.%s.update({\n", varName, modelCamel)
		fmt.Fprintf(b, "      where: { id: %s },\n", idParam)
		b.WriteString("      data: {\n")
		for _, p := range ep.Params {
			name := sanitizeParamName(p.Name)
			if name == "task_id" || name == "user_id" || strings.HasSuffix(name, "Id") {
				continue
			}
			// Map param name to Prisma field name
			prismaField, paramRef := mapParamToPrismaField(p.Name, targetModel)
			if prismaField != paramRef {
				fmt.Fprintf(b, "        %s: %s,\n", prismaField, paramRef)
			} else {
				fmt.Fprintf(b, "        %s,\n", name)
			}
		}
		b.WriteString("      },\n")
		b.WriteString("    });\n\n")

	case "delete":
		model := inferModelFromAction(step.Text, app)
		modelCamel := toCamelCase(model)

		idParam := findIdParam(ep)
		if idParam == "" {
			idParam = "req.body.id"
		}

		varName := resultVarName(resultIdx)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    %s = await prisma.%s.delete({\n", varName, modelCamel)
		fmt.Fprintf(b, "      where: { id: %s },\n", idParam)
		b.WriteString("    });\n\n")

	case "respond":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		if isSignUp {
			// SignUp response: include token
			lastVar := lastResultVar(*resultIdx)
			fmt.Fprintf(b, "    const token = signToken(%s.id, %s.role);\n", lastVar, lastVar)
			fmt.Fprintf(b, "    return res.json({ data: %s, token });\n\n", lastVar)
		} else {
			lastVar := lastResultVar(*resultIdx)
			fmt.Fprintf(b, "    return res.json({ data: %s });\n\n", lastVar)
		}

	case "condition":
		writeConditionStep(b, step, resultIdx)

	case "assign":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		b.WriteString("    // TODO: implement assignment logic\n\n")

	case "send":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		b.WriteString("    // TODO: implement notification/email sending\n\n")

	case "validate":
		fmt.Fprintf(b, "    // %s\n", step.Text)

	default:
		fmt.Fprintf(b, "    // %s\n", step.Text)
	}
}

// writeConditionStep generates code for condition-type steps.
func writeConditionStep(b *strings.Builder, step *ir.Action, resultIdx *int) {
	lower := strings.ToLower(step.Text)

	if strings.Contains(lower, "does not exist") || strings.Contains(lower, "not found") {
		msg := extractRespondMessage(step.Text)
		if msg == "" {
			msg = "Not found"
		}
		lastVar := lastResultVar(*resultIdx)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    if (!%s) {\n", lastVar)
		fmt.Fprintf(b, "      return res.status(404).json({ error: '%s' });\n", msg)
		b.WriteString("    }\n\n")
	} else {
		fmt.Fprintf(b, "    // %s\n", step.Text)
	}
}

// ── Result Variable Helpers ──

// resultVarName returns the next result variable name and increments the counter.
func resultVarName(idx *int) string {
	name := "const result"
	if *idx > 0 {
		name = fmt.Sprintf("const result%d", *idx+1)
	}
	*idx++
	return name
}

// lastResultVar returns the name of the most recently declared result variable.
func lastResultVar(idx int) string {
	if idx <= 1 {
		return "result"
	}
	return fmt.Sprintf("result%d", idx)
}

// ── Model Inference ──

// inferModelFromAction extracts a likely model name from action text.
// Uses app.Data to match known model names when heuristics fail.
func inferModelFromAction(text string, app *ir.Application) string {
	lower := strings.ToLower(text)
	words := strings.Fields(text)

	// Look for common patterns: capitalized word after article
	for i, w := range words {
		wl := strings.ToLower(w)
		if wl == "a" || wl == "an" || wl == "the" || wl == "all" {
			continue
		}
		if i > 0 {
			prev := strings.ToLower(words[i-1])
			if prev == "a" || prev == "an" || prev == "the" || prev == "all" {
				if len(w) > 0 && w[0] >= 'A' && w[0] <= 'Z' {
					return w
				}
			}
		}
	}

	// Fallback: look for capitalized words after the verb
	if len(words) > 1 {
		for _, w := range words[1:] {
			if len(w) > 0 && w[0] >= 'A' && w[0] <= 'Z' {
				return w
			}
		}
	}

	// Check lowercase words against known model names from app.Data
	if app != nil {
		knownModels := buildModelNameSet(app)
		for _, w := range strings.Fields(lower) {
			singular := singularize(w)
			if name, ok := knownModels[singular]; ok {
				return name
			}
			if name, ok := knownModels[w]; ok {
				return name
			}
		}
	}

	// Last fallback: derive from "tasks" → "task", "users" → "user"
	for _, w := range strings.Fields(lower) {
		if strings.HasSuffix(w, "tasks") {
			return "Task"
		}
		if strings.HasSuffix(w, "users") {
			return "User"
		}
		if strings.HasSuffix(w, "profiles") || w == "profile" {
			return "User"
		}
	}

	return "Record"
}

// buildModelNameSet returns a map of lowercase model name → original name.
func buildModelNameSet(app *ir.Application) map[string]string {
	m := make(map[string]string)
	for _, model := range app.Data {
		m[strings.ToLower(model.Name)] = model.Name
	}
	return m
}

// inferModelFromEndpoint derives a model name from a field used in validation.
// Deprecated: use inferModelFromEndpointWithApp for proper model resolution.
func inferModelFromEndpoint(field string) string {
	lower := strings.ToLower(field)
	if lower == "email" || lower == "username" {
		return "user"
	}
	return "record"
}

// inferModelFromEndpointWithApp derives a Prisma model name from a field used in validation,
// checking app.Data for models that contain the field.
func inferModelFromEndpointWithApp(field string, app *ir.Application) string {
	lower := strings.ToLower(field)

	// Check app.Data for a model containing this field
	if app != nil {
		for _, m := range app.Data {
			for _, f := range m.Fields {
				if strings.EqualFold(f.Name, field) {
					return toCamelCase(m.Name)
				}
			}
		}
	}

	// Fallback heuristic
	if lower == "email" || lower == "username" {
		return "user"
	}
	return "record"
}

// ── Endpoint Classification Helpers ──

// isSignUpEndpoint returns true if the endpoint name indicates a user registration.
func isSignUpEndpoint(name string) bool {
	lower := strings.ToLower(name)
	return strings.Contains(lower, "signup") || strings.Contains(lower, "sign_up") ||
		lower == "register" || strings.Contains(lower, "registration")
}

// isLoginEndpoint returns true if the endpoint name indicates authentication.
func isLoginEndpoint(name string) bool {
	lower := strings.ToLower(name)
	return lower == "login" || strings.Contains(lower, "signin") || strings.Contains(lower, "sign_in")
}

// ── Query Modifier Detection ──

// isQueryModifier returns true if the step text is a query modifier
// (sort, filter, paginate) rather than a standalone query.
func isQueryModifier(text string) bool {
	lower := strings.ToLower(text)
	return strings.HasPrefix(lower, "sort ") ||
		strings.HasPrefix(lower, "support ") ||
		strings.HasPrefix(lower, "paginate ") ||
		strings.HasPrefix(lower, "filter ") ||
		strings.Contains(lower, "searching by") ||
		strings.Contains(lower, "filtering by")
}

// ── Default Assignment Detection ──

// isDefaultAssignment returns true if the step sets a default value
// (e.g., "set status to pending if not provided").
func isDefaultAssignment(text string) bool {
	lower := strings.ToLower(text)
	return strings.Contains(lower, "if not provided") || strings.Contains(lower, "if not specified")
}

// setDefaultRe matches "set FIELD to VALUE if not provided/specified".
var setDefaultRe = regexp.MustCompile(`(?i)set\s+(\w+)\s+to\s+(\w+)\s+if\s+not\s+(provided|specified)`)

// parseDefaultAssignment extracts field and default value from text like
// "set status to pending if not provided".
func parseDefaultAssignment(text string) (field, value string) {
	m := setDefaultRe.FindStringSubmatch(text)
	if len(m) >= 3 {
		return m[1], m[2]
	}
	return "field", "default"
}

// ── Model Relationship Helpers ──

// modelBelongsToUser returns true if the given model has a belongs_to User relation.
func modelBelongsToUser(modelName string, app *ir.Application) bool {
	if app == nil {
		return false
	}
	for _, m := range app.Data {
		if strings.EqualFold(m.Name, modelName) {
			for _, r := range m.Relations {
				if r.Kind == "belongs_to" && strings.EqualFold(r.Target, "User") {
					return true
				}
			}
		}
	}
	return false
}

// findModel looks up a DataModel by name (case-insensitive) in the app.
func findModel(name string, app *ir.Application) *ir.DataModel {
	if app == nil {
		return nil
	}
	for _, m := range app.Data {
		if strings.EqualFold(m.Name, name) {
			return m
		}
	}
	return nil
}

// ── ID Parameter Resolution ──

// findIdParam finds the ID-like parameter from an endpoint's param list.
// Returns the sanitized param name (e.g., "task_id") or empty string.
func findIdParam(ep *ir.Endpoint) string {
	for _, p := range ep.Params {
		name := sanitizeParamName(p.Name)
		lower := strings.ToLower(name)
		if strings.HasSuffix(lower, "_id") || strings.HasSuffix(lower, "id") && lower != "id" {
			return name
		}
		if lower == "id" {
			return name
		}
	}
	return ""
}

// isSingleFetch returns true if the step text indicates a single-record fetch
// (e.g., "fetch the task by task_id").
func isSingleFetch(text string) bool {
	lower := strings.ToLower(text)
	// "fetch the X by Y" or "get the X by Y" — singular fetch
	if (strings.Contains(lower, "fetch the") || strings.Contains(lower, "get the")) &&
		strings.Contains(lower, " by ") &&
		!strings.Contains(lower, " all ") {
		return true
	}
	return false
}

// ── Field Name Mapping ──

// mapParamToPrismaField maps a raw param name to (prismaFieldName, sanitizedParamVar).
// Handles cases like param "due date" → Prisma field "due", var "dueDate".
func mapParamToPrismaField(paramName string, model *ir.DataModel) (prismaName string, paramRef string) {
	sanitized := sanitizeParamName(paramName)

	if model == nil {
		return sanitized, sanitized
	}

	// Direct match: sanitized name matches a model field
	for _, f := range model.Fields {
		if f.Name == sanitized {
			return f.Name, sanitized
		}
	}

	// Compound name: param "due date" where field is "due" with type "date"
	for _, f := range model.Fields {
		nameAndType := f.Name + " " + f.Type
		if strings.EqualFold(nameAndType, paramName) {
			return f.Name, sanitized
		}
	}

	return sanitized, sanitized
}

// ── Response Message Extraction ──

// extractRespondMessage extracts a message from condition text like
// "if user does not exist, respond with invalid credentials".
func extractRespondMessage(text string) string {
	lower := strings.ToLower(text)
	idx := strings.Index(lower, "respond with ")
	if idx >= 0 {
		msg := text[idx+len("respond with "):]
		msg = strings.TrimSpace(msg)
		// Capitalize first letter
		if len(msg) > 0 {
			msg = strings.ToUpper(msg[:1]) + msg[1:]
		}
		return msg
	}
	return ""
}
