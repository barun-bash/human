package node

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateRouteIndex produces src/routes/index.ts that registers all routes.
func generateRouteIndex(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { Router } from 'express';\n")

	// Import each route handler
	for _, ep := range app.APIs {
		varName := toCamelCase(ep.Name) + "Router"
		fileName := toKebabCase(ep.Name)
		fmt.Fprintf(&b, "import { router as %s } from './%s';\n", varName, fileName)
	}

	b.WriteString("\nconst router = Router();\n\n")

	// Mount each route
	for _, ep := range app.APIs {
		varName := toCamelCase(ep.Name) + "Router"
		path := routePath(ep.Name)
		fmt.Fprintf(&b, "router.use('%s', %s);\n", path, varName)
	}

	b.WriteString("\nexport { router };\n")

	return b.String()
}

// generateRoute produces a single Express route file for an endpoint.
func generateRoute(ep *ir.Endpoint, app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { Router, Request, Response, NextFunction } from 'express';\n")
	b.WriteString("import { PrismaClient } from '@prisma/client';\n")

	if ep.Auth {
		b.WriteString("import { authenticate } from '../middleware/auth';\n")
	}

	b.WriteString("\nconst prisma = new PrismaClient();\n")
	b.WriteString("const router = Router();\n\n")

	method := httpMethod(ep.Name)

	// Build middleware chain
	middlewares := []string{}
	if ep.Auth {
		middlewares = append(middlewares, "authenticate")
	}

	// Route handler
	if len(middlewares) > 0 {
		fmt.Fprintf(&b, "router.%s('/',\n  %s,\n  async (req: Request, res: Response, next: NextFunction) => {\n",
			method, strings.Join(middlewares, ",\n  "))
	} else {
		fmt.Fprintf(&b, "router.%s('/', async (req: Request, res: Response, next: NextFunction) => {\n", method)
	}

	b.WriteString("  try {\n")

	// Extract params
	if len(ep.Params) > 0 {
		paramNames := make([]string, len(ep.Params))
		for i, p := range ep.Params {
			paramNames[i] = sanitizeParamName(p.Name)
		}
		if method == "get" || method == "delete" {
			fmt.Fprintf(&b, "    const { %s } = req.query as Record<string, string>;\n", strings.Join(paramNames, ", "))
		} else {
			fmt.Fprintf(&b, "    const { %s } = req.body;\n", strings.Join(paramNames, ", "))
		}
		b.WriteString("\n")
	}

	// Validation rules
	if len(ep.Validation) > 0 {
		b.WriteString("    // Validation\n")
		for _, v := range ep.Validation {
			writeValidationCheck(&b, v)
		}
		b.WriteString("\n")
	}

	// Steps as comments with skeleton code
	for _, step := range ep.Steps {
		writeStepCode(&b, step, ep)
	}

	b.WriteString("  } catch (error) {\n")
	b.WriteString("    next(error);\n")
	b.WriteString("  }\n")

	if len(middlewares) > 0 {
		b.WriteString("});\n")
	} else {
		b.WriteString("});\n")
	}

	b.WriteString("\nexport { router };\n")

	return b.String()
}

// writeValidationCheck writes a validation guard for a single rule.
func writeValidationCheck(b *strings.Builder, v *ir.ValidationRule) {
	field := sanitizeParamName(v.Field)

	switch v.Rule {
	case "not_empty":
		fmt.Fprintf(b, "    if (!%s || %s.trim() === '') {\n", field, field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s is required' });\n", v.Field)
		b.WriteString("    }\n")

	case "valid_email":
		fmt.Fprintf(b, "    if (!%s || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(%s)) {\n", field, field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: 'Invalid email address' });\n")
		b.WriteString("    }\n")

	case "min_length":
		fmt.Fprintf(b, "    if (!%s || %s.length < %s) {\n", field, field, v.Value)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be at least %s characters' });\n", v.Field, v.Value)
		b.WriteString("    }\n")

	case "max_length":
		fmt.Fprintf(b, "    if (%s && %s.length > %s) {\n", field, field, v.Value)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be less than %s characters' });\n", v.Field, v.Value)
		b.WriteString("    }\n")

	case "unique":
		modelName := inferModelFromEndpoint(field)
		fmt.Fprintf(b, "    const existing = await prisma.%s.findUnique({ where: { %s } });\n", modelName, field)
		b.WriteString("    if (existing) {\n")
		fmt.Fprintf(b, "      return res.status(409).json({ error: '%s is already taken' });\n", v.Field)
		b.WriteString("    }\n")

	case "future_date":
		fmt.Fprintf(b, "    if (new Date(%s) <= new Date()) {\n", field)
		fmt.Fprintf(b, "      return res.status(400).json({ error: '%s must be in the future' });\n", v.Field)
		b.WriteString("    }\n")

	case "matches":
		fmt.Fprintf(b, "    // TODO: validate that %s matches expected pattern\n", v.Field)

	case "authorization":
		b.WriteString("    // TODO: verify user authorization\n")
		fmt.Fprintf(b, "    // Rule: current user %s\n", v.Value)
	}
}

// writeStepCode writes handler code for a single action step.
func writeStepCode(b *strings.Builder, step *ir.Action, ep *ir.Endpoint) {
	switch step.Type {
	case "create":
		model := inferModelFromAction(step.Text)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    const result = await prisma.%s.create({\n", toCamelCase(model))
		b.WriteString("      data: {\n")
		for _, p := range ep.Params {
			name := sanitizeParamName(p.Name)
			fmt.Fprintf(b, "        %s,\n", name)
		}
		b.WriteString("      },\n")
		b.WriteString("    });\n\n")

	case "query":
		model := inferModelFromAction(step.Text)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    const result = await prisma.%s.findMany();\n\n", toCamelCase(model))

	case "update":
		model := inferModelFromAction(step.Text)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    const result = await prisma.%s.update({\n", toCamelCase(model))
		b.WriteString("      where: { id: req.params.id },\n")
		b.WriteString("      data: {\n")
		for _, p := range ep.Params {
			name := sanitizeParamName(p.Name)
			if name == "task_id" || name == "user_id" || strings.HasSuffix(name, "Id") {
				continue
			}
			fmt.Fprintf(b, "        %s,\n", name)
		}
		b.WriteString("      },\n")
		b.WriteString("    });\n\n")

	case "delete":
		model := inferModelFromAction(step.Text)
		fmt.Fprintf(b, "    // %s\n", step.Text)
		fmt.Fprintf(b, "    const result = await prisma.%s.delete({\n", toCamelCase(model))
		b.WriteString("      where: { id: req.params.id },\n")
		b.WriteString("    });\n\n")

	case "respond":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		b.WriteString("    return res.json({ data: result });\n\n")

	case "assign":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		b.WriteString("    // TODO: implement assignment logic\n\n")

	case "send":
		fmt.Fprintf(b, "    // %s\n", step.Text)
		b.WriteString("    // TODO: implement notification/email sending\n\n")

	case "validate":
		fmt.Fprintf(b, "    // %s\n", step.Text)

	default:
		fmt.Fprintf(b, "    // %s\n", step.Text)
	}
}

// inferModelFromAction extracts a likely model name from action text.
// "create a User with the given fields" → "User"
// "fetch all tasks for the current user" → "Task"
func inferModelFromAction(text string) string {
	lower := strings.ToLower(text)
	words := strings.Fields(text)

	// Look for common patterns
	for i, w := range words {
		wl := strings.ToLower(w)
		// Skip articles and prepositions
		if wl == "a" || wl == "an" || wl == "the" || wl == "all" {
			continue
		}
		// After create/update/delete/fetch, the next capitalized non-article word is the model
		if i > 0 {
			prev := strings.ToLower(words[i-1])
			if prev == "a" || prev == "an" || prev == "the" || prev == "all" {
				if len(w) > 0 && w[0] >= 'A' && w[0] <= 'Z' {
					return w
				}
			}
		}
	}

	// Fallback: look for capitalized words after the verb
	for _, w := range words[1:] {
		if len(w) > 0 && w[0] >= 'A' && w[0] <= 'Z' {
			return w
		}
	}

	// Last fallback: derive from "tasks" → "task", "users" → "user"
	for _, w := range strings.Fields(lower) {
		if strings.HasSuffix(w, "tasks") {
			return "Task"
		}
		if strings.HasSuffix(w, "users") {
			return "User"
		}
		if strings.HasSuffix(w, "profiles") || w == "profile" {
			return "User"
		}
	}

	return "Record"
}

// inferModelFromEndpoint derives a model name from a field used in validation.
func inferModelFromEndpoint(field string) string {
	lower := strings.ToLower(field)
	if lower == "email" || lower == "username" {
		return "user"
	}
	return "record"
}
