package node

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// ParsedRule represents a semantically parsed policy rule.
// Whether the rule is a permission or restriction is determined by
// its position in the Policy (Permissions vs Restrictions list).
type ParsedRule struct {
	Action    string // create, view, edit, delete, export
	Model     string // task, user, data, etc.
	Scope     string // own, any, all, or "" (unspecified)
	Limit     int    // 0 = no limit; >0 = max count
	Period    string // month, day, week, or ""
	Condition string // completed, active, etc.
	RawText   string
}

// parseRuleText extracts structured information from a policy rule's raw text.
func parseRuleText(text string) ParsedRule {
	lower := strings.ToLower(strings.TrimSpace(text))
	words := strings.Fields(lower)

	rule := ParsedRule{RawText: text}
	if len(words) == 0 {
		return rule
	}

	// First word is the action verb
	rule.Action = words[0]

	// Scope detection
	switch {
	case strings.Contains(lower, "only their own"):
		rule.Scope = "own"
	case strings.Contains(lower, "any of their own"):
		rule.Scope = "own"
	case containsWord(words, "any"):
		rule.Scope = "any"
	case containsWord(words, "all"):
		rule.Scope = "all"
	}

	// Quantity limit: "up to N <model> per <period>"
	if idx := strings.Index(lower, "up to "); idx >= 0 {
		remaining := strings.Fields(lower[idx+6:])
		if len(remaining) >= 1 {
			if n, err := strconv.Atoi(remaining[0]); err == nil {
				rule.Limit = n
			}
		}
		// Extract model: the word between number and "per" (skip "per" itself)
		if len(remaining) >= 2 && remaining[1] != "per" {
			rule.Model = singularize(remaining[1])
		}
		if pIdx := strings.Index(lower, " per "); pIdx >= 0 {
			periodParts := strings.Fields(lower[pIdx+5:])
			if len(periodParts) >= 1 {
				rule.Period = periodParts[0]
			}
		}
		return rule
	}

	// "unlimited <model>" — no limit
	if strings.Contains(lower, "unlimited") {
		idx := strings.Index(lower, "unlimited ")
		if idx >= 0 {
			parts := strings.Fields(lower[idx+10:])
			if len(parts) >= 1 {
				rule.Model = singularize(parts[0])
			}
		}
		return rule
	}

	// Condition modifiers
	conditions := []string{"completed", "active", "archived", "pending", "draft", "published", "expired"}
	for _, c := range conditions {
		if containsWord(words, c) {
			rule.Condition = c
			break
		}
	}

	// Extract model — prefer the noun immediately after scope modifiers
	articles := map[string]bool{"the": true, "a": true, "an": true, "of": true}

	// Try scope-based extraction first: "all users", "any task", "own tasks"
	scopeAnchors := []string{"all", "any", "own"}
	for _, anchor := range scopeAnchors {
		for i, w := range words {
			if w == anchor && i+1 < len(words) {
				next := words[i+1]
				// Skip articles between scope and model
				if articles[next] && i+2 < len(words) {
					next = words[i+2]
				}
				if next != rule.Action && next != "of" && next != "their" {
					rule.Model = singularize(next)
					return rule
				}
			}
		}
	}

	// Fallback: last significant word after the action
	skip := map[string]bool{
		"only": true, "their": true, "own": true, "any": true, "all": true,
		"of": true, "the": true, "a": true, "an": true, "and": true,
		"system": true, "up": true, "to": true, "per": true, "unlimited": true,
		"that": true, "which": true, "where": true, "are": true, "is": true,
	}
	for _, c := range conditions {
		skip[c] = true
	}

	for i := len(words) - 1; i >= 1; i-- {
		w := words[i]
		if skip[w] || w == rule.Action {
			continue
		}
		rule.Model = singularize(w)
		break
	}

	// Special case: "export data" — "data" gets skipped by fallback
	if rule.Model == "" && containsWord(words, "data") {
		rule.Model = "data"
	}

	return rule
}

// singularize performs basic English singularization.
func singularize(word string) string {
	if word == "data" || word == "analytics" {
		return word
	}
	if strings.HasSuffix(word, "ies") && len(word) > 3 {
		return word[:len(word)-3] + "y"
	}
	if strings.HasSuffix(word, "ses") || strings.HasSuffix(word, "xes") {
		return word[:len(word)-2]
	}
	if strings.HasSuffix(word, "s") && !strings.HasSuffix(word, "ss") && len(word) > 1 {
		return word[:len(word)-1]
	}
	return word
}

// containsWord checks if a word exists in a word list.
func containsWord(words []string, target string) bool {
	for _, w := range words {
		if w == target {
			return true
		}
	}
	return false
}

// generatePolicies produces src/middleware/policies.ts defining all policy rules.
func generatePolicies(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	// TypeScript interfaces
	b.WriteString(`export interface PolicyRule {
  action: string;
  model: string;
  scope: 'own' | 'any' | 'all' | '';
  limit?: number;
  period?: string;
  condition?: string;
}

export interface PolicyDefinition {
  name: string;
  permissions: PolicyRule[];
  restrictions: PolicyRule[];
}

`)

	// Policy map
	b.WriteString("export const policies: Record<string, PolicyDefinition> = {\n")

	for _, pol := range app.Policies {
		fmt.Fprintf(&b, "  %s: {\n", pol.Name)
		fmt.Fprintf(&b, "    name: '%s',\n", pol.Name)

		// Permissions
		b.WriteString("    permissions: [\n")
		for _, perm := range pol.Permissions {
			r := parseRuleText(perm.Text)
			b.WriteString("      { ")
			fmt.Fprintf(&b, "action: '%s', model: '%s', scope: '%s'", r.Action, r.Model, r.Scope)
			if r.Limit > 0 {
				fmt.Fprintf(&b, ", limit: %d", r.Limit)
			}
			if r.Period != "" {
				fmt.Fprintf(&b, ", period: '%s'", r.Period)
			}
			if r.Condition != "" {
				fmt.Fprintf(&b, ", condition: '%s'", r.Condition)
			}
			b.WriteString(" },\n")
		}
		b.WriteString("    ],\n")

		// Restrictions
		b.WriteString("    restrictions: [\n")
		for _, rest := range pol.Restrictions {
			r := parseRuleText(rest.Text)
			b.WriteString("      { ")
			fmt.Fprintf(&b, "action: '%s', model: '%s', scope: '%s'", r.Action, r.Model, r.Scope)
			if r.Limit > 0 {
				fmt.Fprintf(&b, ", limit: %d", r.Limit)
			}
			if r.Period != "" {
				fmt.Fprintf(&b, ", period: '%s'", r.Period)
			}
			if r.Condition != "" {
				fmt.Fprintf(&b, ", condition: '%s'", r.Condition)
			}
			b.WriteString(" },\n")
		}
		b.WriteString("    ],\n")

		b.WriteString("  },\n")
	}

	b.WriteString("};\n")

	return b.String()
}

// generateAuthorize produces src/middleware/authorize.ts for policy enforcement.
func generateAuthorize(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { Request, Response, NextFunction } from 'express';\n")
	b.WriteString("import { policies } from './policies';\n\n")

	// Extend Express Request with authz scope
	b.WriteString(`declare global {
  namespace Express {
    interface Request {
      authzScope?: 'own' | 'any' | 'all';
    }
  }
}

`)

	// authorize middleware factory
	b.WriteString("/**\n")
	b.WriteString(" * Authorization middleware — checks the user's role against defined policies.\n")
	b.WriteString(" *\n")
	b.WriteString(" * Usage:\n")
	b.WriteString(" *   router.post('/', authenticate, authorize('create', 'task'), handler);\n")
	b.WriteString(" *\n")
	b.WriteString(" * Behavior:\n")
	b.WriteString(" *   1. If a restriction matches the action+model → 403 denied\n")
	b.WriteString(" *   2. If a permission matches → allowed (scope attached to req.authzScope)\n")
	b.WriteString(" *   3. If no rule matches → allowed (no policy opinion)\n")
	b.WriteString(" */\n")
	b.WriteString("export function authorize(action: string, model: string) {\n")
	b.WriteString("  return (req: Request, res: Response, next: NextFunction) => {\n")
	b.WriteString("    const role = req.userRole;\n")
	b.WriteString("    if (!role) {\n")
	b.WriteString("      return res.status(403).json({ error: 'No role assigned' });\n")
	b.WriteString("    }\n")
	b.WriteString("\n")
	b.WriteString("    const policy = policies[role];\n")
	b.WriteString("    if (!policy) {\n")
	b.WriteString("      // No policy defined for this role — allow by default\n")
	b.WriteString("      return next();\n")
	b.WriteString("    }\n")
	b.WriteString("\n")
	b.WriteString("    // Check restrictions first (deny takes precedence)\n")
	b.WriteString("    const denied = policy.restrictions.find(\n")
	b.WriteString("      r => r.action === action && (r.model === model || r.model === '*')\n")
	b.WriteString("    );\n")
	b.WriteString("    if (denied) {\n")
	b.WriteString("      return res.status(403).json({\n")
	b.WriteString("        error: `${role} cannot ${action} ${model}`,\n")
	b.WriteString("      });\n")
	b.WriteString("    }\n")
	b.WriteString("\n")
	b.WriteString("    // Check permissions\n")
	b.WriteString("    const allowed = policy.permissions.find(\n")
	b.WriteString("      r => r.action === action && (r.model === model || r.model === '*')\n")
	b.WriteString("    );\n")
	b.WriteString("    if (allowed) {\n")
	b.WriteString("      // Attach scope for downstream query filtering\n")
	b.WriteString("      if (allowed.scope === 'own') {\n")
	b.WriteString("        req.authzScope = 'own';\n")
	b.WriteString("      }\n")
	b.WriteString("    }\n")
	b.WriteString("\n")
	b.WriteString("    // No matching rule — allow by default (policy has no opinion)\n")
	b.WriteString("    next();\n")
	b.WriteString("  };\n")
	b.WriteString("}\n")

	return b.String()
}

// inferRouteAction derives a CRUD action from an endpoint name.
func inferRouteAction(name string) string {
	lower := strings.ToLower(name)
	switch {
	case strings.HasPrefix(lower, "create"):
		return "create"
	case strings.HasPrefix(lower, "get") || strings.HasPrefix(lower, "list") || strings.HasPrefix(lower, "fetch"):
		return "view"
	case strings.HasPrefix(lower, "update") || strings.HasPrefix(lower, "edit"):
		return "edit"
	case strings.HasPrefix(lower, "delete") || strings.HasPrefix(lower, "remove"):
		return "delete"
	default:
		return ""
	}
}

// inferRouteModel derives the model name from the endpoint name suffix.
func inferRouteModel(name string) string {
	for _, prefix := range []string{"Create", "Get", "List", "Fetch", "Update", "Edit", "Delete", "Remove"} {
		if strings.HasPrefix(name, prefix) && len(name) > len(prefix) {
			return singularize(strings.ToLower(name[len(prefix):]))
		}
	}
	return ""
}
