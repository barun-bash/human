package postgres

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateSeed produces a seed.sql with sample data for development.
func generateSeed(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("-- Generated by Human compiler â€” do not edit\n")
	b.WriteString("-- Seed data for development\n\n")

	b.WriteString("BEGIN;\n\n")

	// Generate sample inserts for each non-join-table model
	for _, model := range app.Data {
		if isJoinTable(model) {
			continue
		}
		writeSeedInsert(&b, model, app)
	}

	// Generate join table inserts after the main tables
	for _, model := range app.Data {
		if isJoinTable(model) {
			writeSeedJoinInsert(&b, model)
		}
	}

	b.WriteString("COMMIT;\n")

	return b.String()
}

// writeSeedInsert generates sample INSERT statements for a model.
func writeSeedInsert(b *strings.Builder, model *ir.DataModel, app *ir.Application) {
	table := toTableName(model.Name)

	// Collect column names and sample values
	var cols []string
	var vals []string

	cols = append(cols, "id")
	idVal := fmt.Sprintf("'00000000-0000-0000-0000-%012d'", seedID(model.Name))
	vals = append(vals, idVal)

	for _, f := range model.Fields {
		name := sanitizeIdentifier(f.Name)
		lower := strings.ToLower(name)
		if lower == "created" || lower == "created_at" || lower == "updated" || lower == "updated_at" {
			continue
		}
		cols = append(cols, name)
		vals = append(vals, sampleValue(f, model))
	}

	// Foreign keys from belongs_to
	for _, rel := range model.Relations {
		if rel.Kind == "belongs_to" {
			col := toSnakeCase(rel.Target) + "_id"
			refID := fmt.Sprintf("'00000000-0000-0000-0000-%012d'", seedID(rel.Target))
			cols = append(cols, col)
			vals = append(vals, refID)
		}
	}

	fmt.Fprintf(b, "INSERT INTO %s (%s)\nVALUES (%s);\n\n",
		table,
		strings.Join(cols, ", "),
		strings.Join(vals, ", "))

	_ = app
}

// writeSeedJoinInsert generates a sample INSERT for a join table.
func writeSeedJoinInsert(b *strings.Builder, model *ir.DataModel) {
	table := toTableName(model.Name)

	var cols []string
	var vals []string

	cols = append(cols, "id")
	vals = append(vals, fmt.Sprintf("'00000000-0000-0000-0000-%012d'", seedID(model.Name)))

	for _, rel := range model.Relations {
		if rel.Kind == "belongs_to" {
			col := toSnakeCase(rel.Target) + "_id"
			refID := fmt.Sprintf("'00000000-0000-0000-0000-%012d'", seedID(rel.Target))
			cols = append(cols, col)
			vals = append(vals, refID)
		}
	}

	fmt.Fprintf(b, "INSERT INTO %s (%s)\nVALUES (%s);\n\n",
		table,
		strings.Join(cols, ", "),
		strings.Join(vals, ", "))
}

// sampleValue returns a sample SQL value for a field.
func sampleValue(f *ir.DataField, model *ir.DataModel) string {
	if f.Type == "enum" && len(f.EnumValues) > 0 {
		return fmt.Sprintf("'%s'", f.EnumValues[0])
	}

	switch strings.ToLower(f.Type) {
	case "text":
		return sampleTextValue(f, model)
	case "email":
		return fmt.Sprintf("'%s@example.com'", strings.ToLower(f.Name))
	case "url", "image", "file":
		return fmt.Sprintf("'https://example.com/%s'", strings.ToLower(f.Name))
	case "number":
		return "1"
	case "decimal":
		return "0.00"
	case "boolean":
		return "true"
	case "date":
		return "'2025-01-15'"
	case "datetime":
		return "'2025-01-15T00:00:00Z'"
	case "json":
		return "'{}'::jsonb"
	default:
		return "'sample'"
	}
}

// sampleTextValue provides contextual sample text based on field name.
func sampleTextValue(f *ir.DataField, model *ir.DataModel) string {
	lower := strings.ToLower(f.Name)
	switch {
	case lower == "name":
		return fmt.Sprintf("'Sample %s'", model.Name)
	case lower == "title":
		return fmt.Sprintf("'Sample %s'", model.Name)
	case lower == "description" || lower == "bio":
		return fmt.Sprintf("'A sample %s for development'", strings.ToLower(model.Name))
	case lower == "password":
		return "'$2b$10$sample.hashed.password.for.dev.only'"
	case lower == "color":
		return "'#6C5CE7'"
	default:
		return fmt.Sprintf("'sample_%s'", lower)
	}
}

// seedID returns a deterministic numeric ID for seed data based on model name.
func seedID(name string) int {
	h := 0
	for _, r := range name {
		h = h*31 + int(r)
	}
	if h < 0 {
		h = -h
	}
	return h % 1000000000000
}
