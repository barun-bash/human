package postgres

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateMigration produces a complete 001_initial.sql migration file.
// Order: enums → tables → indexes → foreign keys.
func generateMigration(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("-- Generated by Human compiler — do not edit\n")
	b.WriteString("-- Migration: 001_initial\n\n")

	b.WriteString("BEGIN;\n\n")

	// 1. Enums
	enums := collectEnums(app)
	if len(enums) > 0 {
		b.WriteString("-- ── Enum Types ──\n\n")
		for _, e := range enums {
			writeEnumType(&b, e)
		}
	}

	// 2. Tables (in dependency order)
	sorted := sortModelsForCreation(app.Data)
	b.WriteString("-- ── Tables ──\n\n")
	for _, model := range sorted {
		writeCreateTable(&b, model, app)
	}

	// 3. Indexes
	if app.Database != nil && len(app.Database.Indexes) > 0 {
		b.WriteString("-- ── Indexes ──\n\n")
		for _, idx := range app.Database.Indexes {
			writeCreateIndex(&b, idx, app)
		}
		b.WriteString("\n")
	}

	// 4. Foreign keys (separate pass so all tables exist first)
	fks := collectForeignKeys(app)
	if len(fks) > 0 {
		b.WriteString("-- ── Foreign Keys ──\n\n")
		for _, fk := range fks {
			writeForeignKey(&b, fk)
		}
	}

	b.WriteString("COMMIT;\n")

	return b.String()
}

// ── Enum collection ──

// enumDef holds data for a CREATE TYPE statement.
type enumDef struct {
	TypeName string
	Values   []string
}

// collectEnums gathers all enum fields across all data models.
func collectEnums(app *ir.Application) []enumDef {
	var enums []enumDef
	for _, model := range app.Data {
		for _, field := range model.Fields {
			if field.Type == "enum" && len(field.EnumValues) > 0 {
				enums = append(enums, enumDef{
					TypeName: enumTypeName(model.Name, field.Name),
					Values:   field.EnumValues,
				})
			}
		}
	}
	return enums
}

func writeEnumType(b *strings.Builder, e enumDef) {
	quoted := make([]string, len(e.Values))
	for i, v := range e.Values {
		quoted[i] = fmt.Sprintf("'%s'", v)
	}
	fmt.Fprintf(b, "CREATE TYPE %s AS ENUM (%s);\n\n", e.TypeName, strings.Join(quoted, ", "))
}

// ── Table creation ──

func writeCreateTable(b *strings.Builder, model *ir.DataModel, app *ir.Application) {
	table := toTableName(model.Name)

	fmt.Fprintf(b, "CREATE TABLE %s (\n", table)

	// Primary key
	b.WriteString("  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n")

	// Fields
	for _, f := range model.Fields {
		writeColumn(b, f, model)
	}

	// Foreign key columns from belongs_to relations
	for _, rel := range model.Relations {
		if rel.Kind == "belongs_to" {
			fkCol := toSnakeCase(rel.Target) + "_id"
			refTable := toTableName(rel.Target)
			fmt.Fprintf(b, "  %s UUID NOT NULL REFERENCES %s(id),\n", fkCol, refTable)
		}
	}

	// Timestamps
	b.WriteString("  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n")
	b.WriteString("  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n")

	fmt.Fprintf(b, ");\n\n")

	_ = app
}

func writeColumn(b *strings.Builder, f *ir.DataField, model *ir.DataModel) {
	name := sanitizeIdentifier(f.Name)

	// Skip fields that map to timestamps
	lower := strings.ToLower(name)
	if lower == "created" || lower == "created_at" || lower == "updated" || lower == "updated_at" {
		return
	}

	var colType string
	if f.Type == "enum" && len(f.EnumValues) > 0 {
		colType = enumTypeName(model.Name, f.Name)
	} else {
		colType = pgType(f.Type)
	}

	constraints := ""
	if f.Required {
		constraints += " NOT NULL"
	}
	if f.Unique {
		constraints += " UNIQUE"
	}
	if f.Default != "" {
		constraints += fmt.Sprintf(" DEFAULT '%s'", f.Default)
	}

	fmt.Fprintf(b, "  %s %s%s,\n", name, colType, constraints)
}

// ── Index creation ──

func writeCreateIndex(b *strings.Builder, idx *ir.Index, app *ir.Application) {
	table := toTableName(idx.Entity)

	// Find the data model for this entity
	var model *ir.DataModel
	for _, m := range app.Data {
		if strings.EqualFold(m.Name, idx.Entity) {
			model = m
			break
		}
	}

	cols := make([]string, len(idx.Fields))
	for i, f := range idx.Fields {
		cols[i] = resolveColumnName(f, model)
	}

	indexName := fmt.Sprintf("idx_%s_%s", table, strings.Join(cols, "_"))
	fmt.Fprintf(b, "CREATE INDEX %s ON %s (%s);\n", indexName, table, strings.Join(cols, ", "))
}

// resolveColumnName maps a raw IR index field name to its actual SQL column name.
// It handles: belongs_to targets ("user" → "user_id"), field name matches
// ("due date" → "due" if the field is named "due"), timestamp aliases
// ("created" → "created_at"), and plain identifiers.
func resolveColumnName(rawField string, model *ir.DataModel) string {
	if model == nil {
		return sanitizeIdentifier(rawField)
	}

	// Check if rawField matches a belongs_to relation target (case-insensitive).
	// e.g. "user" matches belongs_to User → produces "user_id"
	for _, rel := range model.Relations {
		if rel.Kind == "belongs_to" && strings.EqualFold(rel.Target, rawField) {
			return toSnakeCase(rel.Target) + "_id"
		}
	}

	// Handle timestamp aliases first: fields named "created"/"updated" are
	// skipped by writeColumn and replaced with created_at/updated_at columns.
	lower := strings.ToLower(rawField)
	if lower == "created" || lower == "createdat" || lower == "created_at" {
		return "created_at"
	}
	if lower == "updated" || lower == "updatedat" || lower == "updated_at" {
		return "updated_at"
	}

	// Check if rawField matches a DataModel field name (case-insensitive).
	// Also handles prefix matches: "due date" matches field "due" (where "date"
	// is the type that appeared in the natural English reference).
	for _, field := range model.Fields {
		fieldLower := strings.ToLower(field.Name)
		if fieldLower == lower {
			return sanitizeIdentifier(field.Name)
		}
		if strings.HasPrefix(lower, fieldLower+" ") {
			return sanitizeIdentifier(field.Name)
		}
	}

	// Fallback: sanitize the raw string
	return sanitizeIdentifier(rawField)
}

// ── Foreign key collection ──

// fkDef holds data for an ALTER TABLE ... ADD CONSTRAINT statement.
type fkDef struct {
	FromTable  string
	Column     string
	ToTable    string
	Constraint string
}

// collectForeignKeys gathers foreign key relationships.
// belongs_to relations that were inlined as REFERENCES in CREATE TABLE
// don't need separate ALTER TABLE statements, but we emit them as
// named constraints for clarity and consistency.
func collectForeignKeys(app *ir.Application) []fkDef {
	var fks []fkDef
	for _, model := range app.Data {
		for _, rel := range model.Relations {
			if rel.Kind != "belongs_to" {
				continue
			}
			fromTable := toTableName(model.Name)
			toTable := toTableName(rel.Target)
			col := toSnakeCase(rel.Target) + "_id"
			constraint := fmt.Sprintf("fk_%s_%s", fromTable, col)

			fks = append(fks, fkDef{
				FromTable:  fromTable,
				Column:     col,
				ToTable:    toTable,
				Constraint: constraint,
			})
		}
	}
	return fks
}

func writeForeignKey(b *strings.Builder, fk fkDef) {
	fmt.Fprintf(b, "ALTER TABLE %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s(id);\n",
		fk.FromTable, fk.Constraint, fk.Column, fk.ToTable)
}
