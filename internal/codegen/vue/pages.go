package vue

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

func generatePage(page *ir.Page, app *ir.Application) string {
	var b strings.Builder

	needsNavigate := false
	needsState := false
	needsEffect := false

	for _, a := range page.Content {
		switch a.Type {
		case "navigate":
			needsNavigate = true
		case "interact":
			if strings.Contains(strings.ToLower(a.Text), "navigate") {
				needsNavigate = true
			}
		case "query":
			needsState = true
			needsEffect = true
		case "input":
			needsState = true
		case "loop":
			needsState = true
		}
	}

	b.WriteString("<!-- Generated by Human compiler â€” do not edit -->\\n")
	b.WriteString("<script setup lang=\"ts\">\\n")
	
	vueImports := []string{}
	if needsState {
		vueImports = append(vueImports, "ref")
	}
	if needsEffect {
		vueImports = append(vueImports, "onMounted")
	}
	if len(vueImports) > 0 {
		fmt.Fprintf(&b, "import { %s } from 'vue';\\n", strings.Join(vueImports, ", "))
	}
	if needsNavigate {
		b.WriteString("import { useRouter } from 'vue-router';\\n")
	}

	if needsNavigate || needsState || needsEffect {
		b.WriteString("\\n")
	}

	if needsNavigate {
		b.WriteString("const router = useRouter();\\n")
	}
	if needsState {
		b.WriteString("const loading = ref(true);\\n")
		b.WriteString("const data = ref<unknown[]>([]);\\n")
	}
	if needsEffect {
		b.WriteString("\\nonMounted(() => {\\n")
		b.WriteString("  // TODO: fetch data\\n")
		b.WriteString("  loading.value = false;\\n")
		b.WriteString("});\\n")
	}

	b.WriteString("</script>\\n\\n")

	b.WriteString("<template>\\n")
	fmt.Fprintf(&b, "  <div class=\"%s-page\">\\n", toKebabCase(page.Name))

	for _, a := range page.Content {
		writePageActionVue(&b, a, "    ")
	}

	b.WriteString("  </div>\\n")
	b.WriteString("</template>\\n")

	return b.String()
}

func writePageActionVue(b *strings.Builder, a *ir.Action, indent string) {
	lower := strings.ToLower(a.Text)

	fmt.Fprintf(b, "%s<!-- %s -->\\n", indent, a.Text)

	switch a.Type {
	case "display":
		className := slugify(a.Text)
		fmt.Fprintf(b, "%s<div class=\"%s\">%s</div>\\n", indent, className, a.Text)

	case "input":
		if strings.Contains(lower, "search") {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"Search...\" @input=\"/* TODO: handle search */\" />\\n", indent)
		} else if strings.Contains(lower, "dropdown") || strings.Contains(lower, "select") {
			fmt.Fprintf(b, "%s<select @change=\"/* TODO: handle selection */\">\\n", indent)
			fmt.Fprintf(b, "%s  <option>Select...</option>\\n", indent)
			fmt.Fprintf(b, "%s</select>\\n", indent)
		} else {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"%s\" />\\n", indent, a.Text)
		}

	case "interact":
		if strings.Contains(lower, "clicking") || strings.Contains(lower, "click") {
			label := extractButtonLabel(a.Text)
			if strings.Contains(lower, "navigate") {
				target := extractNavTarget(a.Text)
				fmt.Fprintf(b, "%s<button @click=\"router.push('/%s')\">%s</button>\\n", indent, toKebabCase(target), label)
			} else {
				fmt.Fprintf(b, "%s<button @click=\"/* TODO */\">%s</button>\\n", indent, label)
			}
		} else {
			fmt.Fprintf(b, "%s<div class=\"interactive\">%s</div>\\n", indent, a.Text)
		}

	case "navigate":
		target := extractNavTarget(a.Text)
		fmt.Fprintf(b, "%s<button @click=\"router.push('/%s')\">Go to %s</button>\\n", indent, toKebabCase(target), target)

	case "condition":
		if strings.Contains(lower, "while loading") || strings.Contains(lower, "is loading") {
			fmt.Fprintf(b, "%s<div v-if=\"loading\" class=\"loading\">Loading...</div>\\n", indent)
		} else if strings.Contains(lower, "if no ") || strings.Contains(lower, "if there are no") {
			fmt.Fprintf(b, "%s<div v-if=\"data.length === 0\" class=\"empty-state\">%s</div>\\n", indent, a.Text)
		} else {
			fmt.Fprintf(b, "%s<!-- Condition: %s -->\\n", indent, a.Text)
		}

	case "loop":
		fmt.Fprintf(b, "%s<div v-for=\"(item, index) in data\" :key=\"index\">\\n", indent)
		fmt.Fprintf(b, "%s  <!-- %s -->\\n", indent, a.Text)
		fmt.Fprintf(b, "%s</div>\\n", indent)

	case "query":
		// Queries handled by onMounted

	default:
		fmt.Fprintf(b, "%s<div>%s</div>\\n", indent, a.Text)
	}
}

func slugify(s string) string {
	var result []rune
	for _, r := range strings.ToLower(s) {
		if r >= 'a' && r <= 'z' || r >= '0' && r <= '9' {
			result = append(result, r)
		} else if r == ' ' || r == '-' || r == '_' {
			if len(result) > 0 && result[len(result)-1] != '-' {
				result = append(result, '-')
			}
		}
	}
	if len(result) > 0 && result[len(result)-1] == '-' {
		result = result[:len(result)-1]
	}
	return string(result)
}

func extractButtonLabel(text string) string {
	lower := strings.ToLower(text)
	if idx := strings.Index(lower, "clicking the "); idx != -1 {
		after := text[idx+len("clicking the "):]
		if end := strings.Index(strings.ToLower(after), " button"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " navigates"); end != -1 {
			return after[:end]
		}
	}
	return "Click"
}

func extractNavTarget(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{"navigates to ", "navigate to ", "go to "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			target := strings.TrimSpace(text[idx+len(marker):])
			if space := strings.IndexByte(target, ' '); space != -1 {
				target = target[:space]
			}
			return target
		}
	}
	return "home"
}
