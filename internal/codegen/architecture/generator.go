package architecture

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// Generator produces architecture-specific configuration files from Intent IR.
// For monolith: no-op (default behavior).
// For microservices: docker-compose per service, gateway config, service templates.
// For serverless: SAM/Lambda templates.
type Generator struct{}

// Generate writes architecture configuration files to outputDir.
func (g Generator) Generate(app *ir.Application, outputDir string) error {
	if app.Architecture == nil {
		return nil // monolith is the default, no extra files needed
	}

	style := strings.ToLower(app.Architecture.Style)

	switch {
	case strings.Contains(style, "microservice"):
		return g.generateMicroservices(app, outputDir)
	case strings.Contains(style, "serverless"):
		return g.generateServerless(app, outputDir)
	default:
		// monolith or event-driven monolith — no extra files
		return nil
	}
}

func (g Generator) generateMicroservices(app *ir.Application, outputDir string) error {
	files := map[string]string{
		filepath.Join(outputDir, "docker-compose.services.yml"): generateServicesCompose(app),
	}

	// Per-service Dockerfiles
	for _, svc := range app.Architecture.Services {
		svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
		files[filepath.Join(outputDir, "services", svcName, "Dockerfile")] = generateServiceDockerfile(app, svc)
		files[filepath.Join(outputDir, "services", svcName, "README.md")] = generateServiceReadme(app, svc)
	}

	// Gateway config
	if app.Architecture.Gateway != nil {
		files[filepath.Join(outputDir, "gateway", "nginx.conf")] = generateNginxGateway(app)
		files[filepath.Join(outputDir, "gateway", "Dockerfile")] = generateGatewayDockerfile()
	}

	for path, content := range files {
		if err := writeFile(path, content); err != nil {
			return err
		}
	}

	return nil
}

func (g Generator) generateServerless(app *ir.Application, outputDir string) error {
	files := map[string]string{
		filepath.Join(outputDir, "template.yaml"): generateSAMTemplate(app),
	}

	// Per-API Lambda handler stubs
	for _, api := range app.APIs {
		fnName := strings.ToLower(strings.ReplaceAll(api.Name, " ", "-"))
		var handlerFile, handlerContent string
		if isPythonBackend(app) {
			handlerFile = "main.py"
			handlerContent = generateLambdaHandlerPython(app, api)
		} else if isGoBackend(app) {
			handlerFile = "main.go"
			handlerContent = generateLambdaHandlerGo(app, api)
		} else {
			handlerFile = "index.ts"
			handlerContent = generateLambdaHandler(app, api)
		}
		files[filepath.Join(outputDir, "functions", fnName, handlerFile)] = handlerContent
	}

	for path, content := range files {
		if err := writeFile(path, content); err != nil {
			return err
		}
	}

	return nil
}

func writeFile(path, content string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory %s: %w", dir, err)
	}
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing %s: %w", path, err)
	}
	return nil
}

func appNameLower(app *ir.Application) string {
	if app.Name != "" {
		return strings.ToLower(strings.ReplaceAll(app.Name, " ", "-"))
	}
	return "app"
}

func isNodeBackend(app *ir.Application) bool {
	if app.Config == nil || app.Config.Backend == "" {
		return true
	}
	return strings.Contains(strings.ToLower(app.Config.Backend), "node")
}

func isPythonBackend(app *ir.Application) bool {
	if app.Config == nil {
		return false
	}
	return strings.Contains(strings.ToLower(app.Config.Backend), "python")
}

// titleCase uppercases the first byte of s (ASCII-safe replacement for deprecated strings.Title).
func titleCase(s string) string {
	if s == "" {
		return s
	}
	if s[0] >= 'a' && s[0] <= 'z' {
		return string(s[0]-32) + s[1:]
	}
	return s
}

func isGoBackend(app *ir.Application) bool {
	if app.Config == nil {
		return false
	}
	lower := strings.ToLower(app.Config.Backend)
	return lower == "go" || strings.HasPrefix(lower, "go ") || strings.Contains(lower, "gin") || strings.Contains(lower, "fiber")
}

// ── Microservices ──

func generateServicesCompose(app *ir.Application) string {
	var b strings.Builder
	name := appNameLower(app)

	b.WriteString("# Generated by Human compiler — Microservices Docker Compose\n\n")
	b.WriteString("services:\n")

	for _, svc := range app.Architecture.Services {
		svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
		port := svc.Port
		if port == 0 {
			port = 3000
		}

		b.WriteString(fmt.Sprintf("\n  %s:\n", svcName))
		b.WriteString(fmt.Sprintf("    build: ./services/%s\n", svcName))
		b.WriteString("    ports:\n")
		b.WriteString(fmt.Sprintf("      - \"%d:%d\"\n", port, port))
		b.WriteString("    environment:\n")
		b.WriteString(fmt.Sprintf("      - SERVICE_NAME=%s\n", svcName))
		b.WriteString(fmt.Sprintf("      - PORT=%d\n", port))

		if svc.HasOwnDatabase {
			dbName := strings.ReplaceAll(svcName, "-", "_")
			b.WriteString(fmt.Sprintf("      - DATABASE_URL=postgresql://postgres:postgres@%s-db:5432/%s\n", svcName, dbName))
		}

		b.WriteString("    networks:\n")
		b.WriteString(fmt.Sprintf("      - %s-net\n", name))

		if svc.HasOwnDatabase {
			b.WriteString("    depends_on:\n")
			b.WriteString(fmt.Sprintf("      - %s-db\n", svcName))
		}
	}

	// Per-service databases
	for _, svc := range app.Architecture.Services {
		if !svc.HasOwnDatabase {
			continue
		}
		svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
		dbName := strings.ReplaceAll(svcName, "-", "_")

		b.WriteString(fmt.Sprintf("\n  %s-db:\n", svcName))
		b.WriteString("    image: postgres:16-alpine\n")
		b.WriteString("    environment:\n")
		b.WriteString(fmt.Sprintf("      - POSTGRES_DB=%s\n", dbName))
		b.WriteString("      - POSTGRES_PASSWORD=postgres\n")
		b.WriteString("    volumes:\n")
		b.WriteString(fmt.Sprintf("      - %s-db-data:/var/lib/postgresql/data\n", svcName))
		b.WriteString("    networks:\n")
		b.WriteString(fmt.Sprintf("      - %s-net\n", name))
	}

	// Gateway
	if app.Architecture.Gateway != nil {
		b.WriteString(fmt.Sprintf("\n  gateway:\n"))
		b.WriteString("    build: ./gateway\n")
		b.WriteString("    ports:\n")
		b.WriteString("      - \"80:80\"\n")
		b.WriteString("    networks:\n")
		b.WriteString(fmt.Sprintf("      - %s-net\n", name))
		b.WriteString("    depends_on:\n")
		for _, svc := range app.Architecture.Services {
			svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
			b.WriteString(fmt.Sprintf("      - %s\n", svcName))
		}
	}

	// Message broker
	if app.Architecture.Broker != "" {
		broker := strings.ToLower(app.Architecture.Broker)
		switch {
		case strings.Contains(broker, "rabbit"):
			b.WriteString(fmt.Sprintf("\n  rabbitmq:\n"))
			b.WriteString("    image: rabbitmq:3-management-alpine\n")
			b.WriteString("    ports:\n")
			b.WriteString("      - \"5672:5672\"\n")
			b.WriteString("      - \"15672:15672\"\n")
			b.WriteString("    networks:\n")
			b.WriteString(fmt.Sprintf("      - %s-net\n", name))
		case strings.Contains(broker, "kafka"):
			b.WriteString(fmt.Sprintf("\n  kafka:\n"))
			b.WriteString("    image: confluentinc/cp-kafka:7.5.0\n")
			b.WriteString("    ports:\n")
			b.WriteString("      - \"9092:9092\"\n")
			b.WriteString("    environment:\n")
			b.WriteString("      - KAFKA_BROKER_ID=1\n")
			b.WriteString("      - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181\n")
			b.WriteString("      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092\n")
			b.WriteString("    networks:\n")
			b.WriteString(fmt.Sprintf("      - %s-net\n", name))
			b.WriteString("    depends_on:\n")
			b.WriteString("      - zookeeper\n\n")

			b.WriteString("  zookeeper:\n")
			b.WriteString("    image: confluentinc/cp-zookeeper:7.5.0\n")
			b.WriteString("    environment:\n")
			b.WriteString("      - ZOOKEEPER_CLIENT_PORT=2181\n")
			b.WriteString("    networks:\n")
			b.WriteString(fmt.Sprintf("      - %s-net\n", name))
		}
	}

	// Networks
	b.WriteString(fmt.Sprintf("\nnetworks:\n  %s-net:\n", name))

	// Volumes
	hasVolumes := false
	for _, svc := range app.Architecture.Services {
		if svc.HasOwnDatabase {
			if !hasVolumes {
				b.WriteString("\nvolumes:\n")
				hasVolumes = true
			}
			svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
			b.WriteString(fmt.Sprintf("  %s-db-data:\n", svcName))
		}
	}

	return b.String()
}

func generateServiceDockerfile(app *ir.Application, svc *ir.ServiceDef) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler\n")

	if isPythonBackend(app) {
		b.WriteString("FROM python:3.12-slim\n")
		b.WriteString("WORKDIR /app\n")
		b.WriteString("COPY requirements.txt .\n")
		b.WriteString("RUN pip install --no-cache-dir -r requirements.txt\n")
		b.WriteString("COPY . .\n")
		port := svc.Port
		if port == 0 {
			port = 3000
		}
		b.WriteString(fmt.Sprintf("EXPOSE %d\n", port))
		b.WriteString("CMD [\"python\", \"main.py\"]\n")
	} else if isGoBackend(app) {
		b.WriteString("FROM golang:1.21-alpine AS builder\n")
		b.WriteString("WORKDIR /app\n")
		b.WriteString("COPY go.mod go.sum ./\n")
		b.WriteString("RUN go mod download\n")
		b.WriteString("COPY . .\n")
		b.WriteString("RUN CGO_ENABLED=0 go build -o server .\n\n")
		b.WriteString("FROM alpine:3.19\n")
		b.WriteString("COPY --from=builder /app/server /server\n")
		port := svc.Port
		if port == 0 {
			port = 3000
		}
		b.WriteString(fmt.Sprintf("EXPOSE %d\n", port))
		b.WriteString("CMD [\"/server\"]\n")
	} else {
		// Node.js (default)
		b.WriteString("FROM node:20-alpine\n")
		b.WriteString("WORKDIR /app\n")
		b.WriteString("COPY package*.json ./\n")
		b.WriteString("RUN npm ci --only=production\n")
		b.WriteString("COPY . .\n")
		port := svc.Port
		if port == 0 {
			port = 3000
		}
		b.WriteString(fmt.Sprintf("EXPOSE %d\n", port))
		b.WriteString("CMD [\"node\", \"dist/index.js\"]\n")
	}

	return b.String()
}

func generateServiceReadme(app *ir.Application, svc *ir.ServiceDef) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("# %s\n\n", svc.Name))

	if svc.Handles != "" {
		b.WriteString(fmt.Sprintf("**Responsibility:** %s\n\n", svc.Handles))
	}

	if svc.Port != 0 {
		b.WriteString(fmt.Sprintf("**Port:** %d\n\n", svc.Port))
	}

	if len(svc.Models) > 0 {
		b.WriteString("**Data Models:**\n")
		for _, m := range svc.Models {
			b.WriteString(fmt.Sprintf("- %s\n", m))
		}
		b.WriteString("\n")
	}

	if svc.HasOwnDatabase {
		b.WriteString("**Database:** Dedicated PostgreSQL instance\n\n")
	}

	if len(svc.TalksTo) > 0 {
		b.WriteString("**Communicates with:**\n")
		for _, t := range svc.TalksTo {
			b.WriteString(fmt.Sprintf("- %s\n", t))
		}
		b.WriteString("\n")
	}

	b.WriteString(fmt.Sprintf("Part of the %s application.\n", app.Name))

	return b.String()
}

// ── Gateway ──

func generateNginxGateway(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler — API Gateway (nginx)\n\n")
	b.WriteString("events {\n")
	b.WriteString("    worker_connections 1024;\n")
	b.WriteString("}\n\n")
	b.WriteString("http {\n")

	// Upstreams
	for _, svc := range app.Architecture.Services {
		svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
		port := svc.Port
		if port == 0 {
			port = 3000
		}
		b.WriteString(fmt.Sprintf("    upstream %s {\n", svcName))
		b.WriteString(fmt.Sprintf("        server %s:%d;\n", svcName, port))
		b.WriteString("    }\n\n")
	}

	b.WriteString("    server {\n")
	b.WriteString("        listen 80;\n\n")

	// Route mappings from gateway definition
	if app.Architecture.Gateway != nil && len(app.Architecture.Gateway.Routes) > 0 {
		// Sort routes for deterministic output
		routePaths := make([]string, 0, len(app.Architecture.Gateway.Routes))
		for path := range app.Architecture.Gateway.Routes {
			routePaths = append(routePaths, path)
		}
		sort.Strings(routePaths)

		for _, path := range routePaths {
			svcName := app.Architecture.Gateway.Routes[path]
			target := strings.ToLower(strings.ReplaceAll(svcName, " ", "-"))
			b.WriteString(fmt.Sprintf("        location %s {\n", path))
			b.WriteString(fmt.Sprintf("            proxy_pass http://%s;\n", target))
			b.WriteString("            proxy_set_header Host $host;\n")
			b.WriteString("            proxy_set_header X-Real-IP $remote_addr;\n")
			b.WriteString("            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n")
			b.WriteString("        }\n\n")
		}
	} else {
		// Auto-generate routes from service names
		for _, svc := range app.Architecture.Services {
			svcName := strings.ToLower(strings.ReplaceAll(svc.Name, " ", "-"))
			b.WriteString(fmt.Sprintf("        location /api/%s/ {\n", svcName))
			b.WriteString(fmt.Sprintf("            proxy_pass http://%s;\n", svcName))
			b.WriteString("            proxy_set_header Host $host;\n")
			b.WriteString("            proxy_set_header X-Real-IP $remote_addr;\n")
			b.WriteString("        }\n\n")
		}
	}

	// Health check
	b.WriteString("        location /health {\n")
	b.WriteString("            return 200 'OK';\n")
	b.WriteString("            add_header Content-Type text/plain;\n")
	b.WriteString("        }\n")

	b.WriteString("    }\n")
	b.WriteString("}\n")

	return b.String()
}

func generateGatewayDockerfile() string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler\n")
	b.WriteString("FROM nginx:alpine\n")
	b.WriteString("COPY nginx.conf /etc/nginx/nginx.conf\n")
	b.WriteString("EXPOSE 80\n")

	return b.String()
}

// ── Serverless (AWS SAM) ──

func generateSAMTemplate(app *ir.Application) string {
	var b strings.Builder
	name := appNameLower(app)

	b.WriteString("# Generated by Human compiler — AWS SAM Template\n")
	b.WriteString("AWSTemplateFormatVersion: '2010-09-09'\n")
	b.WriteString("Transform: AWS::Serverless-2016-10-31\n\n")
	b.WriteString(fmt.Sprintf("Description: %s serverless application\n\n", app.Name))

	b.WriteString("Globals:\n")
	b.WriteString("  Function:\n")
	b.WriteString("    Timeout: 30\n")
	b.WriteString("    MemorySize: 256\n")

	runtime := "nodejs20.x"
	handler := "index.handler"
	if isPythonBackend(app) {
		runtime = "python3.12"
		handler = "main.handler"
	} else if isGoBackend(app) {
		runtime = "provided.al2023"
		handler = "bootstrap"
	}
	b.WriteString(fmt.Sprintf("    Runtime: %s\n", runtime))

	b.WriteString("    Environment:\n")
	b.WriteString("      Variables:\n")
	b.WriteString(fmt.Sprintf("        APP_NAME: %s\n", name))
	b.WriteString("        STAGE: !Ref Stage\n\n")

	b.WriteString("Parameters:\n")
	b.WriteString("  Stage:\n")
	b.WriteString("    Type: String\n")
	b.WriteString("    Default: dev\n")
	b.WriteString("    AllowedValues:\n")
	b.WriteString("      - dev\n")
	b.WriteString("      - staging\n")
	b.WriteString("      - prod\n\n")

	b.WriteString("Resources:\n")

	// API Gateway
	apiGatewayName := sanitizeCFNName(titleCase(name))
	b.WriteString(fmt.Sprintf("  %sApi:\n", apiGatewayName))
	b.WriteString("    Type: AWS::Serverless::Api\n")
	b.WriteString("    Properties:\n")
	b.WriteString("      StageName: !Ref Stage\n")
	b.WriteString("      Cors:\n")
	b.WriteString("        AllowMethods: \"'*'\"\n")
	b.WriteString("        AllowHeaders: \"'Content-Type,Authorization'\"\n")
	b.WriteString("        AllowOrigin: \"'*'\"\n\n")

	// Per-API Lambda functions
	for _, api := range app.APIs {
		fnName := sanitizeCFNName(api.Name)
		fnNameLower := strings.ToLower(strings.ReplaceAll(api.Name, " ", "-"))

		method := inferHTTPMethod(api)
		path := "/" + fnNameLower

		b.WriteString(fmt.Sprintf("  %sFunction:\n", fnName))
		b.WriteString("    Type: AWS::Serverless::Function\n")
		b.WriteString("    Properties:\n")
		b.WriteString(fmt.Sprintf("      CodeUri: functions/%s/\n", fnNameLower))
		b.WriteString(fmt.Sprintf("      Handler: %s\n", handler))
		b.WriteString("      Events:\n")
		b.WriteString(fmt.Sprintf("        %sEvent:\n", fnName))
		b.WriteString("          Type: Api\n")
		b.WriteString("          Properties:\n")
		b.WriteString(fmt.Sprintf("            RestApiId: !Ref %sApi\n", apiGatewayName))
		b.WriteString(fmt.Sprintf("            Path: %s\n", path))
		b.WriteString(fmt.Sprintf("            Method: %s\n\n", method))
	}

	// Outputs
	b.WriteString("Outputs:\n")
	b.WriteString("  ApiUrl:\n")
	b.WriteString(fmt.Sprintf("    Value: !Sub \"https://${%sApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}\"\n", apiGatewayName))

	return b.String()
}

func generateLambdaHandler(app *ir.Application, api *ir.Endpoint) string {
	var b strings.Builder
	_ = app

	b.WriteString("// Generated by Human compiler — Lambda handler\n\n")
	b.WriteString("import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n")

	b.WriteString(fmt.Sprintf("export async function handler(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n"))
	b.WriteString("  try {\n")

	if len(api.Params) > 0 {
		b.WriteString("    const body = JSON.parse(event.body || '{}');\n")
	}

	// Generate step comments
	for _, step := range api.Steps {
		b.WriteString(fmt.Sprintf("    // TODO: %s\n", step.Text))
	}

	b.WriteString("\n    return {\n")
	b.WriteString("      statusCode: 200,\n")
	b.WriteString("      headers: { 'Content-Type': 'application/json' },\n")
	b.WriteString(fmt.Sprintf("      body: JSON.stringify({ message: '%s completed' }),\n", api.Name))
	b.WriteString("    };\n")
	b.WriteString("  } catch (error) {\n")
	b.WriteString("    return {\n")
	b.WriteString("      statusCode: 500,\n")
	b.WriteString("      body: JSON.stringify({ error: 'Internal Server Error' }),\n")
	b.WriteString("    };\n")
	b.WriteString("  }\n")
	b.WriteString("}\n")

	return b.String()
}

func generateLambdaHandlerPython(app *ir.Application, api *ir.Endpoint) string {
	var b strings.Builder
	_ = app

	b.WriteString("# Generated by Human compiler — Lambda handler\n\n")
	b.WriteString("import json\n\n\n")
	b.WriteString("def handler(event, context):\n")
	b.WriteString("    try:\n")

	if len(api.Params) > 0 {
		b.WriteString("        body = json.loads(event.get('body', '{}'))\n")
	}

	for _, step := range api.Steps {
		b.WriteString(fmt.Sprintf("        # TODO: %s\n", step.Text))
	}

	b.WriteString("\n        return {\n")
	b.WriteString("            'statusCode': 200,\n")
	b.WriteString("            'headers': {'Content-Type': 'application/json'},\n")
	b.WriteString(fmt.Sprintf("            'body': json.dumps({'message': '%s completed'}),\n", api.Name))
	b.WriteString("        }\n")
	b.WriteString("    except Exception as e:\n")
	b.WriteString("        return {\n")
	b.WriteString("            'statusCode': 500,\n")
	b.WriteString("            'body': json.dumps({'error': 'Internal Server Error'}),\n")
	b.WriteString("        }\n")

	return b.String()
}

func generateLambdaHandlerGo(app *ir.Application, api *ir.Endpoint) string {
	var b strings.Builder
	_ = app

	b.WriteString("// Generated by Human compiler — Lambda handler\n")
	b.WriteString("package main\n\n")
	b.WriteString("import (\n")
	b.WriteString("\t\"context\"\n")
	b.WriteString("\t\"encoding/json\"\n\n")
	b.WriteString("\t\"github.com/aws/aws-lambda-go/events\"\n")
	b.WriteString("\t\"github.com/aws/aws-lambda-go/lambda\"\n")
	b.WriteString(")\n\n")

	b.WriteString("func handler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\n")

	for _, step := range api.Steps {
		b.WriteString(fmt.Sprintf("\t// TODO: %s\n", step.Text))
	}

	b.WriteString(fmt.Sprintf("\n\tbody, _ := json.Marshal(map[string]string{\"message\": \"%s completed\"})\n", api.Name))
	b.WriteString("\treturn events.APIGatewayProxyResponse{\n")
	b.WriteString("\t\tStatusCode: 200,\n")
	b.WriteString("\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n")
	b.WriteString("\t\tBody:       string(body),\n")
	b.WriteString("\t}, nil\n")
	b.WriteString("}\n\n")
	b.WriteString("func main() {\n")
	b.WriteString("\tlambda.Start(handler)\n")
	b.WriteString("}\n")

	return b.String()
}

// sanitizeCFNName removes non-alphanumeric characters for valid CloudFormation resource names.
func sanitizeCFNName(name string) string {
	var b strings.Builder
	for _, r := range name {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
		}
	}
	result := b.String()
	if result == "" {
		return "Resource"
	}
	return result
}

func inferHTTPMethod(api *ir.Endpoint) string {
	name := strings.ToLower(api.Name)
	for _, step := range api.Steps {
		stepType := strings.ToLower(step.Type)
		switch stepType {
		case "create":
			return "POST"
		case "update":
			return "PUT"
		case "delete":
			return "DELETE"
		case "query":
			return "GET"
		}
	}
	// Infer from name
	switch {
	case strings.HasPrefix(name, "create") || strings.HasPrefix(name, "signup") || strings.HasPrefix(name, "login") || strings.HasPrefix(name, "register"):
		return "POST"
	case strings.HasPrefix(name, "update") || strings.HasPrefix(name, "edit"):
		return "PUT"
	case strings.HasPrefix(name, "delete") || strings.HasPrefix(name, "remove"):
		return "DELETE"
	default:
		return "GET"
	}
}
