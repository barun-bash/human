package svelte

import (
	"fmt"
	"strings"
	"unicode"

	"github.com/barun-bash/human/internal/ir"
)

func generatePage(page *ir.Page, app *ir.Application) string {
	var b strings.Builder

	needsNavigate := false
	needsState := false
	needsEffect := false

	for _, a := range page.Content {
		switch a.Type {
		case "navigate":
			needsNavigate = true
		case "interact":
			if strings.Contains(strings.ToLower(a.Text), "navigate") {
				needsNavigate = true
			}
		case "query", "input", "loop":
			needsState = true
			if a.Type == "query" {
				needsEffect = true
			}
		}
	}

	b.WriteString("<!-- Generated by Human compiler — do not edit -->\n")
	b.WriteString("<script lang=\"ts\">\n")

	if needsNavigate {
		b.WriteString("  import { goto } from '$app/navigation';\n")
	}
	if needsEffect {
		b.WriteString("  import * as api from '$lib/api';\n")
	}

	hasModelImport := false
	for _, a := range page.Content {
		if a.Type == "loop" {
			hasModelImport = true
		}
	}
	if hasModelImport {
		b.WriteString("  // import type { ... } from '$lib/types';\n")
	}

	usedComponents := make(map[string]bool)
	for _, a := range page.Content {
		if a.Type == "loop" {
			words := strings.Fields(a.Text)
			if len(words) > 0 {
				lastWord := words[len(words)-1]
				if unicode.IsUpper(rune(lastWord[0])) {
					usedComponents[lastWord] = true
				}
			}
		}
	}

	for comp := range usedComponents {
		fmt.Fprintf(&b, "  import %s from '$lib/components/%s.svelte';\n", comp, comp)
	}

	if needsNavigate || needsState || needsEffect || len(usedComponents) > 0 {
		b.WriteString("\n")
	}

	if needsState {
		b.WriteString("  let loading = $state(true);\n")
		b.WriteString("  let data = $state<any[]>([]);\n\n")
	}

	if needsEffect {
		b.WriteString("  $effect(() => {\n")
		b.WriteString("    // TODO: fetch data via api calls\n")
		b.WriteString("    loading = false;\n")
		b.WriteString("  });\n\n")
	}

	b.WriteString("</script>\n\n")

	fmt.Fprintf(&b, "<div class=\"%s-page\">\n", toKebabCase(page.Name))

	for _, a := range page.Content {
		writeTemplateAction(&b, a, "  ")
	}

	b.WriteString("</div>\n")
	return b.String()
}

func generateComponent(comp *ir.Component, app *ir.Application) string {
	var b strings.Builder

	b.WriteString("<!-- Generated by Human compiler — do not edit -->\n")
	b.WriteString("<script lang=\"ts\">\n")

	hasDataModelImport := false
	for _, prop := range comp.Props {
		if prop.Type != "" && isDataModel(prop.Type, app) {
			hasDataModelImport = true
			break
		}
	}

	if hasDataModelImport {
		models := []string{}
		for _, prop := range comp.Props {
			if prop.Type != "" && isDataModel(prop.Type, app) {
				models = append(models, prop.Type)
			}
		}
		fmt.Fprintf(&b, "  import type { %s } from '$lib/types';\n\n", strings.Join(models, ", "))
	}

	if len(comp.Props) > 0 || hasClickHandler(comp) {
		b.WriteString("  let { ")
		
		var propNames []string
		for _, prop := range comp.Props {
			propNames = append(propNames, prop.Name)
		}
		if hasClickHandler(comp) {
			propNames = append(propNames, "onclick")
		}
		
		b.WriteString(strings.Join(propNames, ", "))
		b.WriteString(" }: { ")
		
		for _, prop := range comp.Props {
			propType := "unknown"
			if prop.Type != "" {
				if isDataModel(prop.Type, app) {
					propType = prop.Type
				} else {
					propType = tsType(prop.Type)
				}
			}
			fmt.Fprintf(&b, "%s: %s; ", prop.Name, propType)
		}
		if hasClickHandler(comp) {
			b.WriteString("onclick?: () => void; ")
		}
		
		b.WriteString("} = $props();\n")
	}

	b.WriteString("</script>\n\n")

	hasClick := hasClickHandler(comp)

	if hasClick {
		fmt.Fprintf(&b, "<div class=\"%s\" {onclick}>\n", toKebabCase(comp.Name))
	} else {
		fmt.Fprintf(&b, "<div class=\"%s\">\n", toKebabCase(comp.Name))
	}

	for _, a := range comp.Content {
		writeTemplateAction(&b, a, "  ")
	}

	b.WriteString("</div>\n")
	return b.String()
}

func writeTemplateAction(b *strings.Builder, a *ir.Action, indent string) {
	lower := strings.ToLower(a.Text)

	fmt.Fprintf(b, "%s<!-- %s -->\n", indent, a.Text)

	switch a.Type {
	case "display":
		className := slugify(a.Text)
		fmt.Fprintf(b, "%s<div class=\"%s\">%s</div>\n", indent, className, a.Text)

	case "input":
		if strings.Contains(lower, "search") {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"Search...\" oninput={() => {}} />\n", indent)
		} else if strings.Contains(lower, "dropdown") || strings.Contains(lower, "select") {
			fmt.Fprintf(b, "%s<select onchange={() => {}}>\n", indent)
			fmt.Fprintf(b, "%s  <option>Select...</option>\n", indent)
			fmt.Fprintf(b, "%s</select>\n", indent)
		} else {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"%s\" />\n", indent, a.Text)
		}

	case "interact":
		if strings.Contains(lower, "clicking") || strings.Contains(lower, "click") {
			label := extractButtonLabel(a.Text)
			if strings.Contains(lower, "navigate") {
				target := extractNavTarget(a.Text)
				fmt.Fprintf(b, "%s<button onclick={() => goto('/%s')}>%s</button>\n", indent, toKebabCase(target), label)
			} else {
				fmt.Fprintf(b, "%s<button onclick={() => {}}>%s</button>\n", indent, label)
			}
		} else {
			fmt.Fprintf(b, "%s<div class=\"interactive\">%s</div>\n", indent, a.Text)
		}

	case "navigate":
		target := extractNavTarget(a.Text)
		fmt.Fprintf(b, "%s<button onclick={() => goto('/%s')}>Go to %s</button>\n", indent, toKebabCase(target), target)

	case "condition":
		if strings.Contains(lower, "while loading") || strings.Contains(lower, "is loading") {
			fmt.Fprintf(b, "%s{#if loading}\n%s  <div class=\"loading\">Loading...</div>\n%s{/if}\n", indent, indent, indent)
		} else if strings.Contains(lower, "if no ") || strings.Contains(lower, "if there are no") {
			fmt.Fprintf(b, "%s{#if data.length === 0}\n%s  <div class=\"empty-state\">%s</div>\n%s{/if}\n", indent, indent, a.Text, indent)
		} else {
			fmt.Fprintf(b, "%s<!-- Condition: %s -->\n", indent, a.Text)
		}

	case "loop":
		words := strings.Fields(a.Text)
		compName := ""
		if len(words) > 0 {
			lastWord := words[len(words)-1]
			if unicode.IsUpper(rune(lastWord[0])) {
				compName = lastWord
			}
		}

		fmt.Fprintf(b, "%s{#each data as item, index}\n", indent)
		if compName != "" {
			fmt.Fprintf(b, "%s  <%s task={item} />\n", indent, compName)
		} else {
			fmt.Fprintf(b, "%s  <!-- %s -->\n", indent, a.Text)
		}
		fmt.Fprintf(b, "%s{/each}\n", indent)

	case "query":
		// Queries handled in script block via $effect

	default:
		fmt.Fprintf(b, "%s<div>%s</div>\n", indent, a.Text)
	}
}

func slugify(s string) string {
	var result []rune
	for _, r := range strings.ToLower(s) {
		if r >= 'a' && r <= 'z' || r >= '0' && r <= '9' {
			result = append(result, r)
		} else if r == ' ' || r == '-' || r == '_' {
			if len(result) > 0 && result[len(result)-1] != '-' {
				result = append(result, '-')
			}
		}
	}
	if len(result) > 0 && result[len(result)-1] == '-' {
		result = result[:len(result)-1]
	}
	return string(result)
}

func extractButtonLabel(text string) string {
	lower := strings.ToLower(text)
	if idx := strings.Index(lower, "clicking the "); idx != -1 {
		after := text[idx+len("clicking the "):]
		if end := strings.Index(strings.ToLower(after), " button"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " navigates"); end != -1 {
			return after[:end]
		}
	}
	return "Click"
}

func extractNavTarget(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{"navigates to ", "navigate to ", "go to "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			target := strings.TrimSpace(text[idx+len(marker):])
			if space := strings.IndexByte(target, ' '); space != -1 {
				target = target[:space]
			}
			return target
		}
	}
	return "home"
}

func isDataModel(typeName string, app *ir.Application) bool {
	for _, m := range app.Data {
		if m.Name == typeName {
			return true
		}
	}
	return false
}

func hasClickHandler(comp *ir.Component) bool {
	for _, a := range comp.Content {
		lower := strings.ToLower(a.Text)
		if strings.Contains(lower, "on_click") || strings.Contains(lower, "onclick") || strings.Contains(lower, "click") {
			return true
		}
	}
	return false
}
