package docker

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateBackendDockerfile dispatches to the correct backend Dockerfile
// generator based on the configured backend framework.
func generateBackendDockerfile(app *ir.Application) string {
	dir := BackendDir(app)
	switch dir {
	case "python":
		return generatePythonDockerfile(app)
	case "go":
		return generateGoDockerfile(app)
	default:
		return generateNodeDockerfile(app)
	}
}

// generateNodeDockerfile produces a Dockerfile for the Node + Express backend.
func generateNodeDockerfile(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler — do not edit\n\n")
	b.WriteString("FROM node:20-alpine AS builder\n\n")
	b.WriteString("WORKDIR /app\n\n")

	// Install dependencies
	b.WriteString("# Install dependencies\n")
	b.WriteString("COPY package.json package-lock.json* ./\n")
	b.WriteString("RUN npm ci\n\n")

	// Copy Prisma schema and generate client
	b.WriteString("# Generate Prisma client\n")
	b.WriteString("COPY prisma ./prisma\n")
	b.WriteString("RUN npx prisma generate\n\n")

	// Copy source and build
	b.WriteString("# Copy source and build\n")
	b.WriteString("COPY . .\n")
	b.WriteString("RUN npm run build\n\n")

	// Production stage
	b.WriteString("# Production\n")
	b.WriteString("FROM node:20-alpine\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("COPY --from=builder /app/package.json ./\n")
	b.WriteString("COPY --from=builder /app/node_modules ./node_modules\n")
	b.WriteString("COPY --from=builder /app/dist ./dist\n")
	b.WriteString("COPY --from=builder /app/prisma ./prisma\n\n")

	b.WriteString("EXPOSE 3000\n\n")
	b.WriteString("CMD [\"node\", \"dist/server.js\"]\n")

	_ = app // used for future customization
	return b.String()
}

// generatePythonDockerfile produces a Dockerfile for a Python + FastAPI backend.
func generatePythonDockerfile(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler — do not edit\n\n")

	// Build stage: install dependencies
	b.WriteString("FROM python:3.12-slim AS builder\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("# Install dependencies\n")
	b.WriteString("COPY requirements.txt ./\n")
	b.WriteString("RUN pip install --no-cache-dir --prefix=/install -r requirements.txt\n\n")

	// Production stage
	b.WriteString("# Production\n")
	b.WriteString("FROM python:3.12-slim\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("COPY --from=builder /install /usr/local\n")
	b.WriteString("COPY . .\n\n")

	b.WriteString("EXPOSE 8000\n\n")
	b.WriteString("CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n")

	_ = app
	return b.String()
}

// generateGoDockerfile produces a multi-stage Dockerfile for a Go backend.
func generateGoDockerfile(app *ir.Application) string {
	var b strings.Builder
	name := AppNameLower(app)

	b.WriteString("# Generated by Human compiler — do not edit\n\n")

	// Build stage
	b.WriteString("FROM golang:1.21-alpine AS builder\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("# Download dependencies\n")
	b.WriteString("COPY go.mod go.sum ./\n")
	b.WriteString("RUN go mod download\n\n")

	b.WriteString("# Build binary\n")
	b.WriteString("COPY . .\n")
	fmt.Fprintf(&b, "RUN CGO_ENABLED=0 GOOS=linux go build -o /%s ./\n\n", name)

	// Production stage
	b.WriteString("# Production\n")
	b.WriteString("FROM alpine:3.19\n\n")
	b.WriteString("RUN apk --no-cache add ca-certificates\n\n")
	b.WriteString("WORKDIR /app\n\n")

	fmt.Fprintf(&b, "COPY --from=builder /%s ./\n\n", name)

	b.WriteString("EXPOSE 8080\n\n")
	fmt.Fprintf(&b, "CMD [\"./%s\"]\n", name)

	return b.String()
}

// generateFrontendDockerfile produces a multi-stage Dockerfile for the frontend.
// For Vite-based frameworks (React, Vue, Svelte) it uses VITE_API_URL;
// for Angular it uses NG_APP_API_URL.
func generateFrontendDockerfile(app *ir.Application) string {
	if app.Config != nil && strings.Contains(strings.ToLower(app.Config.Frontend), "angular") {
		return generateAngularFrontendDockerfile(app)
	}
	return generateViteFrontendDockerfile(app)
}

// generateViteFrontendDockerfile produces a multi-stage Dockerfile for
// Vite-based frontends (React, Vue, Svelte).
func generateViteFrontendDockerfile(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler — do not edit\n\n")

	// Build stage
	b.WriteString("# Build stage\n")
	b.WriteString("FROM node:20-alpine AS builder\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("COPY package.json package-lock.json* ./\n")
	b.WriteString("RUN npm ci\n\n")

	b.WriteString("COPY . .\n\n")

	// Vite inlines env vars at build time — the ARG must be declared
	// before `npm run build` so that VITE_API_URL is available.
	b.WriteString("ARG VITE_API_URL\n")
	b.WriteString("ENV VITE_API_URL=$VITE_API_URL\n\n")

	b.WriteString("RUN npm run build\n\n")

	// Serve stage
	b.WriteString("# Serve stage\n")
	b.WriteString("FROM nginx:alpine\n\n")

	b.WriteString("COPY --from=builder /app/dist /usr/share/nginx/html\n\n")

	// SPA routing: redirect all paths to index.html
	b.WriteString("# SPA routing\n")
	b.WriteString("RUN printf 'server {\\n\\\n")
	b.WriteString("  listen 80;\\n\\\n")
	b.WriteString("  location / {\\n\\\n")
	b.WriteString("    root /usr/share/nginx/html;\\n\\\n")
	b.WriteString("    try_files $uri $uri/ /index.html;\\n\\\n")
	b.WriteString("  }\\n\\\n")
	b.WriteString("}\\n' > /etc/nginx/conf.d/default.conf\n\n")

	b.WriteString("EXPOSE 80\n\n")
	b.WriteString("CMD [\"nginx\", \"-g\", \"daemon off;\"]\n")

	_ = app
	return b.String()
}

// generateAngularFrontendDockerfile produces a multi-stage Dockerfile for Angular.
// Angular uses `ng build` and outputs to dist/app/browser/.
func generateAngularFrontendDockerfile(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# Generated by Human compiler — do not edit\n\n")

	// Build stage
	b.WriteString("# Build stage\n")
	b.WriteString("FROM node:20-alpine AS builder\n\n")
	b.WriteString("WORKDIR /app\n\n")

	b.WriteString("COPY package.json package-lock.json* ./\n")
	b.WriteString("RUN npm ci\n\n")

	b.WriteString("COPY . .\n\n")

	b.WriteString("ARG NG_APP_API_URL\n")
	b.WriteString("ENV NG_APP_API_URL=$NG_APP_API_URL\n\n")

	b.WriteString("RUN npm run build\n\n")

	// Serve stage
	b.WriteString("# Serve stage\n")
	b.WriteString("FROM nginx:alpine\n\n")

	// Angular outputs to dist/app/browser/ by default
	b.WriteString("COPY --from=builder /app/dist/app/browser /usr/share/nginx/html\n\n")

	// SPA routing
	b.WriteString("# SPA routing\n")
	b.WriteString("RUN printf 'server {\\n\\\n")
	b.WriteString("  listen 80;\\n\\\n")
	b.WriteString("  location / {\\n\\\n")
	b.WriteString("    root /usr/share/nginx/html;\\n\\\n")
	b.WriteString("    try_files $uri $uri/ /index.html;\\n\\\n")
	b.WriteString("  }\\n\\\n")
	b.WriteString("}\\n' > /etc/nginx/conf.d/default.conf\n\n")

	b.WriteString("EXPOSE 80\n\n")
	b.WriteString("CMD [\"nginx\", \"-g\", \"daemon off;\"]\n")

	_ = app
	return b.String()
}

// generateBackendDockerignore produces a .dockerignore for the backend directory.
func generateBackendDockerignore(app *ir.Application) string {
	dir := BackendDir(app)
	switch dir {
	case "python":
		return `node_modules
.git
.gitignore
__pycache__
*.pyc
.env
.venv
venv
.mypy_cache
.pytest_cache
`
	case "go":
		return `node_modules
.git
.gitignore
.env
*.test
tmp/
`
	default:
		return `node_modules
.git
.gitignore
dist
.env
npm-debug.log*
`
	}
}

// generateFrontendDockerignore produces a .dockerignore for the frontend directory.
func generateFrontendDockerignore(app *ir.Application) string {
	return `node_modules
.git
.gitignore
dist
.env
npm-debug.log*
`
}
