package docker

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generatePackageJSON produces a root package.json with orchestration scripts.
func generatePackageJSON(app *ir.Application) string {
	var b strings.Builder
	name := AppNameLower(app)
	backendDir := BackendDir(app)

	b.WriteString("{\n")
	fmt.Fprintf(&b, "  \"name\": \"%s\",\n", name)
	b.WriteString("  \"version\": \"0.1.0\",\n")
	b.WriteString("  \"private\": true,\n")
	fmt.Fprintf(&b, "  \"description\": \"%s â€” generated by Human compiler\",\n", app.Name)
	b.WriteString("  \"scripts\": {\n")
	b.WriteString("    \"dev\": \"docker compose up --build\",\n")
	b.WriteString("    \"build\": \"docker compose build\",\n")
	b.WriteString("    \"start\": \"docker compose up -d\",\n")
	b.WriteString("    \"stop\": \"docker compose down\",\n")

	// Database migration scripts depend on the backend runtime.
	switch backendDir {
	case "python":
		fmt.Fprintf(&b, "    \"db:migrate\": \"cd %s && alembic upgrade head\",\n", backendDir)
		fmt.Fprintf(&b, "    \"db:seed\": \"cd %s && python seed.py\"\n", backendDir)
	case "go":
		fmt.Fprintf(&b, "    \"db:migrate\": \"cd %s && go run ./migrations\",\n", backendDir)
		fmt.Fprintf(&b, "    \"db:seed\": \"cd %s && go run ./seed\"\n", backendDir)
	default:
		fmt.Fprintf(&b, "    \"db:migrate\": \"cd %s && npx prisma migrate deploy\",\n", backendDir)
		fmt.Fprintf(&b, "    \"db:seed\": \"cd %s && npx prisma db seed\",\n", backendDir)
		fmt.Fprintf(&b, "    \"db:studio\": \"cd %s && npx prisma studio\"\n", backendDir)
	}
	b.WriteString("  }\n")
	b.WriteString("}\n")

	return b.String()
}
