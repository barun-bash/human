package themes

import (
	"fmt"
	"sort"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// GenerateReactTheme produces theme files for React based on the design system.
// Returns map[relative_path]content.
func GenerateReactTheme(theme *ir.Theme) map[string]string {
	files := make(map[string]string)
	systemID := theme.DesignSystem
	tokens := MergeTokens(systemID, theme)

	// Always generate global.css with CSS variables
	files["src/styles/global.css"] = GenerateCSSVariables(tokens, theme)

	switch systemID {
	case "material":
		files["src/theme.ts"] = generateMaterialReactTheme(theme, tokens)
	case "chakra":
		files["src/theme.ts"] = generateChakraReactTheme(theme, tokens)
	case "ant":
		files["src/theme.ts"] = generateAntReactTheme(theme, tokens)
	case "shadcn":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "react")
		files["src/lib/utils.ts"] = generateShadcnUtils()
	case "tailwind", "untitled":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "react")
	case "bootstrap":
		files["src/styles/custom.scss"] = generateBootstrapCustom(tokens)
	default:
		// No specific design system — generate tailwind config as default
		if systemID == "" {
			files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "react")
		}
	}

	return files
}

// GenerateVueTheme produces theme files for Vue.
func GenerateVueTheme(theme *ir.Theme) map[string]string {
	files := make(map[string]string)
	systemID := theme.DesignSystem
	tokens := MergeTokens(systemID, theme)

	files["src/assets/global.css"] = GenerateCSSVariables(tokens, theme)

	switch systemID {
	case "material":
		files["src/plugins/vuetify.ts"] = generateVuetifyPlugin(theme, tokens)
	case "ant":
		files["src/plugins/antd.ts"] = generateAntVuePlugin(theme)
	case "shadcn":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "vue")
	case "tailwind", "untitled":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "vue")
	default:
		if systemID == "" {
			files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "vue")
		}
	}

	return files
}

// GenerateAngularTheme produces theme files for Angular.
func GenerateAngularTheme(theme *ir.Theme) map[string]string {
	files := make(map[string]string)
	systemID := theme.DesignSystem
	tokens := MergeTokens(systemID, theme)

	files["src/styles.css"] = GenerateCSSVariables(tokens, theme)

	switch systemID {
	case "material":
		files["src/app/theme.ts"] = generateAngularMaterialTheme(tokens)
	case "tailwind", "shadcn", "untitled":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "angular")
	default:
		if systemID == "" {
			files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "angular")
		}
	}

	return files
}

// GenerateSvelteTheme produces theme files for Svelte.
func GenerateSvelteTheme(theme *ir.Theme) map[string]string {
	files := make(map[string]string)
	systemID := theme.DesignSystem
	tokens := MergeTokens(systemID, theme)

	files["src/app.css"] = GenerateCSSVariables(tokens, theme)

	switch systemID {
	case "shadcn":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "svelte")
	case "tailwind", "untitled":
		files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "svelte")
	default:
		if systemID == "" {
			files["tailwind.config.js"] = GenerateTailwindConfig(theme, tokens, "svelte")
		}
	}

	files["src/lib/theme.ts"] = generateSvelteThemeTokens(tokens)

	return files
}

// GenerateTailwindConfig produces tailwind.config.js with custom tokens.
// fw specifies the target framework: "react", "vue", "angular", or "svelte".
func GenerateTailwindConfig(theme *ir.Theme, tokens map[string]string, fw string) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("/** @type {import('tailwindcss').Config} */\n")
	b.WriteString("export default {\n")

	var contentGlob string
	switch fw {
	case "vue":
		contentGlob = "{js,ts,vue}"
	case "svelte":
		contentGlob = "{js,ts,svelte}"
	case "angular":
		contentGlob = "{ts,html}"
	default:
		contentGlob = "{js,ts,jsx,tsx}"
	}
	b.WriteString(fmt.Sprintf("  content: ['./index.html', './src/**/*.%s'],\n", contentGlob))

	if theme != nil && theme.DarkMode {
		b.WriteString("  darkMode: 'class',\n")
	}

	b.WriteString("  theme: {\n")
	b.WriteString("    extend: {\n")

	// Colors
	b.WriteString("      colors: {\n")
	colorKeys := sortedColorKeys(tokens)
	for _, k := range colorKeys {
		name := strings.TrimPrefix(k, "--color-")
		b.WriteString(fmt.Sprintf("        '%s': '%s',\n", name, tokens[k]))
	}
	b.WriteString("      },\n")

	// Border radius
	if r, ok := tokens["--radius"]; ok {
		b.WriteString(fmt.Sprintf("      borderRadius: {\n        DEFAULT: '%s',\n      },\n", r))
	}

	// Spacing
	if sm, ok := tokens["--spacing-sm"]; ok {
		md := tokens["--spacing-md"]
		lg := tokens["--spacing-lg"]
		b.WriteString(fmt.Sprintf("      spacing: {\n        'sm': '%s',\n        'md': '%s',\n        'lg': '%s',\n      },\n", sm, md, lg))
	}

	// Font family
	fontKeys := sortedFontKeys(tokens)
	if len(fontKeys) > 0 {
		b.WriteString("      fontFamily: {\n")
		for _, k := range fontKeys {
			name := strings.TrimPrefix(k, "--font-")
			b.WriteString(fmt.Sprintf("        '%s': ['%s', 'sans-serif'],\n", name, tokens[k]))
		}
		b.WriteString("      },\n")
	}

	b.WriteString("    },\n")
	b.WriteString("  },\n")
	b.WriteString("  plugins: [],\n")
	b.WriteString("};\n")

	return b.String()
}

// GenerateCSSVariables produces a :root CSS block with custom properties.
func GenerateCSSVariables(tokens map[string]string, theme *ir.Theme) string {
	var b strings.Builder

	b.WriteString("/* Generated by Human compiler — do not edit */\n\n")

	// Font imports must come first per CSS spec
	if theme != nil && len(theme.Fonts) > 0 {
		fonts := collectGoogleFonts(theme.Fonts)
		if fonts != "" {
			b.WriteString(fmt.Sprintf("@import url('https://fonts.googleapis.com/css2?%s&display=swap');\n\n", fonts))
		}
	}

	// CSS reset
	b.WriteString("*, *::before, *::after {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\n")

	b.WriteString(":root {\n")

	keys := sortedKeys(tokens)
	for _, k := range keys {
		b.WriteString(fmt.Sprintf("  %s: %s;\n", k, tokens[k]))
	}

	b.WriteString("}\n")

	// Body base styles
	b.WriteString("\nbody {\n")
	b.WriteString("  background-color: var(--color-background, #ffffff);\n")
	b.WriteString("  color: var(--color-text, #111827);\n")
	if theme != nil {
		if f, ok := theme.Fonts["body"]; ok {
			b.WriteString(fmt.Sprintf("  font-family: '%s', sans-serif;\n", f))
		}
	}
	b.WriteString("  line-height: 1.5;\n")
	b.WriteString("  -webkit-font-smoothing: antialiased;\n")
	b.WriteString("}\n")

	// Heading styles
	if theme != nil {
		if f, ok := theme.Fonts["headings"]; ok {
			b.WriteString(fmt.Sprintf("\nh1, h2, h3, h4, h5, h6 {\n  font-family: '%s', sans-serif;\n}\n", f))
		}
	}

	// Dark mode
	if theme != nil && theme.DarkMode {
		b.WriteString("\n@media (prefers-color-scheme: dark) {\n")
		b.WriteString("  :root {\n")
		b.WriteString("    --color-background: #111827;\n")
		b.WriteString("    --color-surface: #1f2937;\n")
		b.WriteString("    --color-text: #f9fafb;\n")
		b.WriteString("  }\n")
		b.WriteString("}\n")

		b.WriteString("\n.dark {\n")
		b.WriteString("  --color-background: #111827;\n")
		b.WriteString("  --color-surface: #1f2937;\n")
		b.WriteString("  --color-text: #f9fafb;\n")
		b.WriteString("}\n")
	}

	return b.String()
}

// ── Per-system theme generators ──

func generateMaterialReactTheme(theme *ir.Theme, tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { createTheme } from '@mui/material/styles';\n\n")

	primary := tokenVal(tokens, "--color-primary", "#1976d2")
	secondary := tokenVal(tokens, "--color-secondary", "#9c27b0")
	error_ := tokenVal(tokens, "--color-error", "#d32f2f")
	bg := tokenVal(tokens, "--color-background", "#ffffff")

	b.WriteString("const theme = createTheme({\n")
	b.WriteString("  palette: {\n")
	b.WriteString(fmt.Sprintf("    primary: { main: '%s' },\n", primary))
	b.WriteString(fmt.Sprintf("    secondary: { main: '%s' },\n", secondary))
	b.WriteString(fmt.Sprintf("    error: { main: '%s' },\n", error_))
	b.WriteString(fmt.Sprintf("    background: { default: '%s' },\n", bg))

	if theme.DarkMode {
		b.WriteString("    mode: 'light', // Toggle to 'dark' for dark mode\n")
	}

	b.WriteString("  },\n")

	// Typography
	if len(theme.Fonts) > 0 {
		b.WriteString("  typography: {\n")
		if f, ok := theme.Fonts["body"]; ok {
			b.WriteString(fmt.Sprintf("    fontFamily: \"'%s', sans-serif\",\n", f))
		}
		if f, ok := theme.Fonts["headings"]; ok {
			for _, h := range []string{"h1", "h2", "h3", "h4", "h5", "h6"} {
				b.WriteString(fmt.Sprintf("    %s: { fontFamily: \"'%s', sans-serif\" },\n", h, f))
			}
		}
		b.WriteString("  },\n")
	}

	// Shape
	if r, ok := tokens["--radius"]; ok {
		b.WriteString(fmt.Sprintf("  shape: { borderRadius: %s },\n", stripPx(r)))
	}

	b.WriteString("});\n\n")
	b.WriteString("export default theme;\n")

	return b.String()
}

func generateChakraReactTheme(theme *ir.Theme, tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { extendTheme } from '@chakra-ui/react';\n\n")

	primary := tokenVal(tokens, "--color-primary", "#3182ce")
	secondary := tokenVal(tokens, "--color-secondary", "#805ad5")

	b.WriteString("const theme = extendTheme({\n")
	b.WriteString("  colors: {\n")
	b.WriteString(fmt.Sprintf("    brand: {\n      500: '%s',\n      600: '%s',\n    },\n", primary, secondary))
	b.WriteString("  },\n")

	if len(theme.Fonts) > 0 {
		b.WriteString("  fonts: {\n")
		if f, ok := theme.Fonts["headings"]; ok {
			b.WriteString(fmt.Sprintf("    heading: \"'%s', sans-serif\",\n", f))
		}
		if f, ok := theme.Fonts["body"]; ok {
			b.WriteString(fmt.Sprintf("    body: \"'%s', sans-serif\",\n", f))
		}
		b.WriteString("  },\n")
	}

	if theme.DarkMode {
		b.WriteString("  config: {\n    initialColorMode: 'light',\n    useSystemColorMode: true,\n  },\n")
	}

	b.WriteString("});\n\n")
	b.WriteString("export default theme;\n")

	return b.String()
}

func generateAntReactTheme(theme *ir.Theme, tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import type { ThemeConfig } from 'antd';\n\n")

	primary := tokenVal(tokens, "--color-primary", "#1677ff")
	error_ := tokenVal(tokens, "--color-error", "#ff4d4f")

	b.WriteString("const themeConfig: ThemeConfig = {\n")
	b.WriteString("  token: {\n")
	b.WriteString(fmt.Sprintf("    colorPrimary: '%s',\n", primary))
	b.WriteString(fmt.Sprintf("    colorError: '%s',\n", error_))

	if r, ok := tokens["--radius"]; ok {
		b.WriteString(fmt.Sprintf("    borderRadius: %s,\n", stripPx(r)))
	}
	if f, ok := theme.Fonts["body"]; ok {
		b.WriteString(fmt.Sprintf("    fontFamily: \"'%s', sans-serif\",\n", f))
	}

	b.WriteString("  },\n")

	if theme.DarkMode {
		b.WriteString("  // Set algorithm: theme.darkAlgorithm for dark mode\n")
	}

	b.WriteString("};\n\n")
	b.WriteString("export default themeConfig;\n")

	return b.String()
}

func generateVuetifyPlugin(theme *ir.Theme, tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import { createVuetify } from 'vuetify';\n")
	b.WriteString("import 'vuetify/styles';\n\n")

	primary := tokenVal(tokens, "--color-primary", "#1976d2")
	secondary := tokenVal(tokens, "--color-secondary", "#9c27b0")
	error_ := tokenVal(tokens, "--color-error", "#d32f2f")

	b.WriteString("export default createVuetify({\n")
	b.WriteString("  theme: {\n")

	if theme.DarkMode {
		b.WriteString("    defaultTheme: 'light',\n")
	}

	b.WriteString("    themes: {\n")
	b.WriteString("      light: {\n")
	b.WriteString("        colors: {\n")
	b.WriteString(fmt.Sprintf("          primary: '%s',\n", primary))
	b.WriteString(fmt.Sprintf("          secondary: '%s',\n", secondary))
	b.WriteString(fmt.Sprintf("          error: '%s',\n", error_))
	b.WriteString("        },\n")
	b.WriteString("      },\n")

	if theme.DarkMode {
		b.WriteString("      dark: {\n")
		b.WriteString("        dark: true,\n")
		b.WriteString("        colors: {\n")
		b.WriteString(fmt.Sprintf("          primary: '%s',\n", primary))
		b.WriteString(fmt.Sprintf("          secondary: '%s',\n", secondary))
		b.WriteString("        },\n")
		b.WriteString("      },\n")
	}

	b.WriteString("    },\n")
	b.WriteString("  },\n")
	b.WriteString("});\n")

	return b.String()
}

func generateAntVuePlugin(theme *ir.Theme) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import Antd from 'ant-design-vue';\n")
	b.WriteString("import 'ant-design-vue/dist/reset.css';\n\n")
	b.WriteString("export default Antd;\n")
	return b.String()
}

func generateAngularMaterialTheme(tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	primary := tokenVal(tokens, "--color-primary", "#1976d2")
	secondary := tokenVal(tokens, "--color-secondary", "#9c27b0")

	b.WriteString("export const themeTokens = {\n")
	b.WriteString(fmt.Sprintf("  primary: '%s',\n", primary))
	b.WriteString(fmt.Sprintf("  secondary: '%s',\n", secondary))
	b.WriteString("};\n")

	return b.String()
}

func generateSvelteThemeTokens(tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("export const theme = {\n")

	keys := sortedKeys(tokens)
	for _, k := range keys {
		// Convert CSS var name to camelCase JS key
		jsKey := cssVarToJS(k)
		b.WriteString(fmt.Sprintf("  %s: '%s',\n", jsKey, tokens[k]))
	}

	b.WriteString("} as const;\n")
	return b.String()
}

func generateShadcnUtils() string {
	return `// Generated by Human compiler — do not edit

import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
`
}

func generateBootstrapCustom(tokens map[string]string) string {
	var b strings.Builder
	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	primary := tokenVal(tokens, "--color-primary", "#0d6efd")
	secondary := tokenVal(tokens, "--color-secondary", "#6c757d")

	b.WriteString("// Bootstrap SCSS variable overrides\n")
	b.WriteString(fmt.Sprintf("$primary: %s;\n", primary))
	b.WriteString(fmt.Sprintf("$secondary: %s;\n", secondary))
	b.WriteString("\n@import 'bootstrap/scss/bootstrap';\n")

	return b.String()
}

// ── Helpers ──

func tokenVal(tokens map[string]string, key, fallback string) string {
	if v, ok := tokens[key]; ok {
		return v
	}
	return fallback
}

func stripPx(s string) string {
	return strings.TrimSuffix(s, "px")
}

func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func sortedColorKeys(m map[string]string) []string {
	var keys []string
	for k := range m {
		if strings.HasPrefix(k, "--color-") {
			keys = append(keys, k)
		}
	}
	sort.Strings(keys)
	return keys
}

func sortedFontKeys(m map[string]string) []string {
	var keys []string
	for k := range m {
		if strings.HasPrefix(k, "--font-") {
			keys = append(keys, k)
		}
	}
	sort.Strings(keys)
	return keys
}

func cssVarToJS(s string) string {
	// "--color-primary" → "colorPrimary"
	s = strings.TrimPrefix(s, "--")
	parts := strings.Split(s, "-")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

func collectGoogleFonts(fonts map[string]string) string {
	seen := make(map[string]bool)
	var families []string
	for _, font := range fonts {
		if !seen[font] {
			seen[font] = true
			families = append(families, "family="+strings.ReplaceAll(font, " ", "+")+":wght@400;500;600;700")
		}
	}
	sort.Strings(families)
	return strings.Join(families, "&")
}
