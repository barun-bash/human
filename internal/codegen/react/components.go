package react

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateComponent produces a reusable React component from an IR Component.
func generateComponent(comp *ir.Component, app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import React from 'react';\n")

	// Check if any prop type matches a data model — if so, import it
	for _, prop := range comp.Props {
		if prop.Type != "" && isDataModel(prop.Type, app) {
			fmt.Fprintf(&b, "import { %s } from '../types/models';\n", prop.Type)
		}
	}

	b.WriteString("\n")

	// Props interface
	if len(comp.Props) > 0 {
		fmt.Fprintf(&b, "interface %sProps {\n", comp.Name)
		for _, prop := range comp.Props {
			propType := "unknown"
			if prop.Type != "" {
				if isDataModel(prop.Type, app) {
					propType = prop.Type
				} else {
					propType = tsType(prop.Type)
				}
			}
			fmt.Fprintf(&b, "  %s: %s;\n", prop.Name, propType)
		}

		// Detect onClick pattern from content actions
		if hasClickHandler(comp) {
			b.WriteString("  onClick?: () => void;\n")
		}

		b.WriteString("}\n\n")
	}

	// Component function
	if len(comp.Props) > 0 {
		fmt.Fprintf(&b, "export default function %s({ %s }: %sProps) {\n",
			comp.Name, propsDestructure(comp), comp.Name)
	} else {
		fmt.Fprintf(&b, "export default function %s() {\n", comp.Name)
	}

	// Build context for JSX generation
	propsMap := make(map[string]string)
	for _, p := range comp.Props {
		propsMap[p.Name] = p.Type
	}
	ctx := &pageContext{
		app:   app,
		props: propsMap,
	}

	// Return JSX
	b.WriteString("  return (\n")
	fmt.Fprintf(&b, "    <div className=\"%s\">\n", toKebabCase(comp.Name))

	for _, a := range comp.Content {
		writePageAction(&b, a, "      ", ctx)
	}

	b.WriteString("    </div>\n")
	b.WriteString("  );\n")
	b.WriteString("}\n")

	return b.String()
}

// isDataModel checks if a type name matches a known data model.
func isDataModel(typeName string, app *ir.Application) bool {
	for _, m := range app.Data {
		if m.Name == typeName {
			return true
		}
	}
	return false
}

// hasClickHandler checks if any component action suggests an onClick handler.
func hasClickHandler(comp *ir.Component) bool {
	for _, a := range comp.Content {
		lower := strings.ToLower(a.Text)
		if strings.Contains(lower, "on_click") || strings.Contains(lower, "onclick") {
			return true
		}
	}
	return false
}

// propsDestructure builds the destructuring pattern for component props.
func propsDestructure(comp *ir.Component) string {
	names := make([]string, 0, len(comp.Props))
	for _, p := range comp.Props {
		names = append(names, p.Name)
	}
	if hasClickHandler(comp) {
		names = append(names, "onClick")
	}
	return strings.Join(names, ", ")
}
