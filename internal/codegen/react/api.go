package react

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateAPIClient produces a typed, fetch-based API client.
func generateAPIClient(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	// Base URL and response type
	b.WriteString("const API_BASE_URL = import.meta.env.VITE_API_URL || '';\n\n")
	b.WriteString(`export interface ApiResponse<T> {
  data: T;
  error?: string;
}
`)

	// Shared request helper
	b.WriteString(`
export async function request<T>(
  method: string,
  path: string,
  body?: Record<string, unknown>,
): Promise<ApiResponse<T>> {
  const token = localStorage.getItem('token');
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  if (token) {
    headers['Authorization'] = ` + "`Bearer ${token}`" + `;
  }
  const res = await fetch(` + "`${API_BASE_URL}${path}`" + `, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });
  return res.json();
}
`)

	// Per-endpoint functions
	for _, ep := range app.APIs {
		b.WriteString("\n")
		writeEndpointFunction(&b, ep)
	}

	return b.String()
}

// writeEndpointFunction writes a single exported async function for an API endpoint.
func writeEndpointFunction(b *strings.Builder, ep *ir.Endpoint) {
	funcName := toCamelCase(ep.Name)
	method := httpMethod(ep.Name)
	path := apiPath(ep.Name)

	// Build params
	if len(ep.Params) > 0 {
		// Build inline param type
		paramFields := make([]string, len(ep.Params))
		for i, p := range ep.Params {
			paramFields[i] = fmt.Sprintf("%s: string", sanitizeParamName(p.Name))
		}
		paramType := fmt.Sprintf("{ %s }", strings.Join(paramFields, "; "))

		fmt.Fprintf(b, "export async function %s(params: %s) {\n", funcName, paramType)
		if method == "GET" {
			b.WriteString("  const qs = new URLSearchParams(params as unknown as Record<string, string>).toString();\n")
			fmt.Fprintf(b, "  return request<unknown>('%s', `%s?${qs}`);\n", method, path)
		} else {
			fmt.Fprintf(b, "  return request<unknown>('%s', '%s', params as unknown as Record<string, unknown>);\n", method, path)
		}
	} else {
		fmt.Fprintf(b, "export async function %s() {\n", funcName)
		fmt.Fprintf(b, "  return request<unknown>('%s', '%s');\n", method, path)
	}
	b.WriteString("}\n")
}

// sanitizeParamName converts a param name to a valid TypeScript identifier.
// "due date" → "dueDate", "task_id" → "task_id"
func sanitizeParamName(name string) string {
	if !strings.Contains(name, " ") {
		return name
	}
	return toCamelCase(name)
}
