package react

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateTypes produces TypeScript interfaces for all data models.
func generateTypes(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler â€” do not edit\n\n")

	for i, model := range app.Data {
		if i > 0 {
			b.WriteString("\n")
		}
		writeInterface(&b, model, app)
	}

	return b.String()
}

// writeInterface writes a single TypeScript interface for a data model.
func writeInterface(b *strings.Builder, model *ir.DataModel, app *ir.Application) {
	fmt.Fprintf(b, "export interface %s {\n", model.Name)

	// Convention: every model has an id field
	b.WriteString("  id: string;\n")

	// Fields
	for _, f := range model.Fields {
		optional := ""
		if !f.Required {
			optional = "?"
		}

		var fieldType string
		if f.Type == "enum" && len(f.EnumValues) > 0 {
			fieldType = tsEnumType(f.EnumValues)
		} else {
			fieldType = tsType(f.Type)
		}

		fmt.Fprintf(b, "  %s%s: %s;\n", f.Name, optional, fieldType)
	}

	// Relationships
	for _, rel := range model.Relations {
		switch rel.Kind {
		case "belongs_to":
			// Foreign key + optional nested object
			fmt.Fprintf(b, "  %sId: string;\n", toCamelCase(rel.Target))
			fmt.Fprintf(b, "  %s?: %s;\n", toCamelCase(rel.Target), rel.Target)
		case "has_many", "has_many_through":
			fmt.Fprintf(b, "  %s?: %s[];\n", toCamelCase(rel.Target)+"s", rel.Target)
		}
	}

	b.WriteString("}\n")
}
