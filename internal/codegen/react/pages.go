package react

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generatePage produces a React page component from an IR Page.
func generatePage(page *ir.Page, app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	// Detect needed imports by scanning actions
	needsNavigate := false
	needsState := false
	needsEffect := false

	for _, a := range page.Content {
		switch a.Type {
		case "navigate":
			needsNavigate = true
		case "interact":
			if strings.Contains(strings.ToLower(a.Text), "navigate") {
				needsNavigate = true
			}
		case "query":
			needsState = true
			needsEffect = true
		case "input":
			needsState = true
		case "loop":
			needsState = true
		}
	}

	// Write imports
	reactImports := []string{}
	if needsState {
		reactImports = append(reactImports, "useState")
	}
	if needsEffect {
		reactImports = append(reactImports, "useEffect")
	}
	if len(reactImports) > 0 {
		fmt.Fprintf(&b, "import React, { %s } from 'react';\n", strings.Join(reactImports, ", "))
	} else {
		b.WriteString("import React from 'react';\n")
	}
	if needsNavigate {
		b.WriteString("import { useNavigate } from 'react-router-dom';\n")
	}

	b.WriteString("\n")

	// Component
	pageName := page.Name + "Page"
	fmt.Fprintf(&b, "export default function %s() {\n", pageName)

	// Hook declarations
	if needsNavigate {
		b.WriteString("  const navigate = useNavigate();\n")
	}
	if needsState {
		b.WriteString("  const [loading, setLoading] = useState(true);\n")
		b.WriteString("  const [data, setData] = useState<unknown[]>([]);\n")
	}
	if needsEffect {
		b.WriteString("\n  useEffect(() => {\n")
		b.WriteString("    // TODO: fetch data\n")
		b.WriteString("    setLoading(false);\n")
		b.WriteString("  }, []);\n")
	}

	// Return JSX
	b.WriteString("\n  return (\n")
	fmt.Fprintf(&b, "    <div className=\"%s-page\">\n", toKebabCase(page.Name))

	for _, a := range page.Content {
		writePageAction(&b, a, "      ")
	}

	b.WriteString("    </div>\n")
	b.WriteString("  );\n")
	b.WriteString("}\n")

	return b.String()
}

// writePageAction maps an IR action to JSX elements.
func writePageAction(b *strings.Builder, a *ir.Action, indent string) {
	lower := strings.ToLower(a.Text)

	// Include original English as a comment
	fmt.Fprintf(b, "%s{/* %s */}\n", indent, a.Text)

	switch a.Type {
	case "display":
		className := slugify(a.Text)
		fmt.Fprintf(b, "%s<div className=\"%s\">%s</div>\n", indent, className, a.Text)

	case "input":
		if strings.Contains(lower, "search") {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"Search...\" onChange={(e) => {/* TODO: handle search */}} />\n", indent)
		} else if strings.Contains(lower, "dropdown") || strings.Contains(lower, "select") {
			fmt.Fprintf(b, "%s<select onChange={(e) => {/* TODO: handle selection */}}>\n", indent)
			fmt.Fprintf(b, "%s  <option>Select...</option>\n", indent)
			fmt.Fprintf(b, "%s</select>\n", indent)
		} else {
			fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"%s\" />\n", indent, a.Text)
		}

	case "interact":
		if strings.Contains(lower, "clicking") || strings.Contains(lower, "click") {
			label := extractButtonLabel(a.Text)
			if strings.Contains(lower, "navigate") {
				target := extractNavTarget(a.Text)
				fmt.Fprintf(b, "%s<button onClick={() => navigate('/%s')}>%s</button>\n", indent, toKebabCase(target), label)
			} else {
				fmt.Fprintf(b, "%s<button onClick={() => {/* TODO */}}>%s</button>\n", indent, label)
			}
		} else {
			fmt.Fprintf(b, "%s<div className=\"interactive\">%s</div>\n", indent, a.Text)
		}

	case "navigate":
		target := extractNavTarget(a.Text)
		fmt.Fprintf(b, "%s<button onClick={() => navigate('/%s')}>Go to %s</button>\n", indent, toKebabCase(target), target)

	case "condition":
		if strings.Contains(lower, "while loading") || strings.Contains(lower, "is loading") {
			fmt.Fprintf(b, "%s{loading && <div className=\"loading\">Loading...</div>}\n", indent)
		} else if strings.Contains(lower, "if no ") || strings.Contains(lower, "if there are no") {
			fmt.Fprintf(b, "%s{data.length === 0 && <div className=\"empty-state\">%s</div>}\n", indent, a.Text)
		} else {
			fmt.Fprintf(b, "%s{/* Condition: %s */}\n", indent, a.Text)
		}

	case "loop":
		fmt.Fprintf(b, "%s{data.map((item, index) => (\n", indent)
		fmt.Fprintf(b, "%s  <div key={index}>{/* %s */}</div>\n", indent, a.Text)
		fmt.Fprintf(b, "%s))}\n", indent)

	case "query":
		// Queries are handled by useEffect; nothing extra in JSX

	default:
		fmt.Fprintf(b, "%s<div>%s</div>\n", indent, a.Text)
	}
}

// slugify converts text to a CSS-friendly class name.
func slugify(s string) string {
	var result []rune
	for _, r := range strings.ToLower(s) {
		if r >= 'a' && r <= 'z' || r >= '0' && r <= '9' {
			result = append(result, r)
		} else if r == ' ' || r == '-' || r == '_' {
			if len(result) > 0 && result[len(result)-1] != '-' {
				result = append(result, '-')
			}
		}
	}
	// Trim trailing dash
	if len(result) > 0 && result[len(result)-1] == '-' {
		result = result[:len(result)-1]
	}
	return string(result)
}

// extractButtonLabel extracts a reasonable button label from action text.
func extractButtonLabel(text string) string {
	lower := strings.ToLower(text)
	// "clicking the X button navigates to Y" → "X"
	if idx := strings.Index(lower, "clicking the "); idx != -1 {
		after := text[idx+len("clicking the "):]
		if end := strings.Index(strings.ToLower(after), " button"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " navigates"); end != -1 {
			return after[:end]
		}
	}
	return "Click"
}

// extractNavTarget extracts the navigation target page name from action text.
func extractNavTarget(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{"navigates to ", "navigate to ", "go to "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			target := strings.TrimSpace(text[idx+len(marker):])
			// Take first word (page name)
			if space := strings.IndexByte(target, ' '); space != -1 {
				target = target[:space]
			}
			return target
		}
	}
	return "home"
}
