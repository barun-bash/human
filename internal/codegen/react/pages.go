package react

import (
	"fmt"
	"sort"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// pageContext provides shared context for JSX generation within a page or component.
type pageContext struct {
	app             *ir.Application
	appName         string
	modelName       string            // primary data model for the page (e.g., "Task")
	varName         string            // data array variable (e.g., "tasks")
	itemVar         string            // loop item variable (e.g., "task")
	props           map[string]string // component props: propName → typeName
	hasSuccessState bool              // whether setSuccess is available
	hasErrorState   bool              // whether setError is available
}

// generatePage produces a React page component from an IR Page.
func generatePage(page *ir.Page, app *ir.Application) string {
	var b strings.Builder

	b.WriteString("// Generated by Human compiler — do not edit\n\n")

	// Detect primary data model from query actions
	modelName, varName, itemVar := detectPageModel(page, app)

	// Scan actions to determine needed imports and state
	// (need to scan before creating ctx so we can set hasSuccessState/hasErrorState)
	needsNavigate := false
	needsDataState := false // for loading + data array (query/loop with model)
	needsEffect := false
	needsAuth := false
	needsFormState := false
	needsSuccess := false
	needsError := false
	hasLoadingCondition := false // whether the page explicitly references loading state

	for _, a := range page.Content {
		lower := strings.ToLower(a.Text)
		switch a.Type {
		case "navigate":
			needsNavigate = true
		case "interact":
			if strings.Contains(lower, "navigate") {
				needsNavigate = true
			}
			if strings.Contains(lower, "opens a form") || strings.Contains(lower, "open a form") {
				needsFormState = true
			}
		case "query":
			needsDataState = true
			needsEffect = true
		case "loop":
			needsDataState = true
			if modelName != "" {
				needsEffect = true
			}
		case "input":
			// FAB button uses setShowForm
			if strings.Contains(lower, "floating button") || strings.Contains(lower, "fab") {
				needsFormState = true
			}
		case "condition":
			if strings.Contains(lower, "logged in") {
				needsAuth = true
			}
			if strings.Contains(lower, "succeed") || strings.Contains(lower, "success") {
				needsSuccess = true
			}
			if strings.Contains(lower, "error") {
				needsError = true
			}
			if strings.Contains(lower, "while loading") || strings.Contains(lower, "is loading") {
				hasLoadingCondition = true
			}
		}
	}

	ctx := &pageContext{
		app:             app,
		appName:         app.Name,
		modelName:       modelName,
		varName:         varName,
		itemVar:         itemVar,
		hasSuccessState: needsSuccess,
		hasErrorState:   needsError,
	}

	// Write imports (react-jsx transform — no React import needed)
	needsUseState := needsDataState || needsAuth || needsFormState || needsSuccess || needsError
	reactImports := []string{}
	if needsUseState {
		reactImports = append(reactImports, "useState")
	}
	if needsEffect {
		reactImports = append(reactImports, "useEffect")
	}
	if len(reactImports) > 0 {
		fmt.Fprintf(&b, "import { %s } from 'react';\n", strings.Join(reactImports, ", "))
	}
	if needsNavigate {
		b.WriteString("import { useNavigate } from 'react-router-dom';\n")
	}

	// Import model type when we have typed data
	if modelName != "" {
		fmt.Fprintf(&b, "import { %s } from '../types/models';\n", modelName)
	}

	// Import API client function if we have a matching list endpoint
	var listEp *ir.Endpoint
	if needsEffect && modelName != "" {
		listEp = findListEndpoint(app, modelName)
		if listEp != nil {
			fmt.Fprintf(&b, "import { %s } from '../api/client';\n", toCamelCase(listEp.Name))
		} else {
			b.WriteString("import { request } from '../api/client';\n")
		}
	}

	// Component imports
	for _, comp := range detectUsedComponents(page) {
		fmt.Fprintf(&b, "import %s from '../components/%s';\n", comp, comp)
	}

	b.WriteString("\n")

	// Component function
	pageName := page.Name + "Page"
	fmt.Fprintf(&b, "export default function %s() {\n", pageName)

	// Hook declarations
	if needsNavigate {
		b.WriteString("  const navigate = useNavigate();\n")
	}
	if needsDataState {
		b.WriteString("  const [loading, setLoading] = useState(true);\n")
		if modelName != "" {
			fmt.Fprintf(&b, "  const [%s, set%s] = useState<%s[]>([]);\n",
				varName, capitalize(varName), modelName)
		} else {
			b.WriteString("  const [data, setData] = useState<unknown[]>([]);\n")
		}
	}
	if needsAuth {
		b.WriteString("  const [isLoggedIn] = useState(false); // TODO: connect to auth context\n")
	}
	if needsFormState {
		b.WriteString("  const [showForm, setShowForm] = useState(false);\n")
	}
	if needsSuccess {
		b.WriteString("  const [success, setSuccess] = useState('');\n")
	}
	if needsError {
		b.WriteString("  const [error, setError] = useState('');\n")
	}

	if needsEffect {
		setterName := "setData"
		if modelName != "" {
			setterName = "set" + capitalize(varName)
		}
		b.WriteString("\n  useEffect(() => {\n")
		if listEp != nil {
			fmt.Fprintf(&b, "    %s()\n", toCamelCase(listEp.Name))
			fmt.Fprintf(&b, "      .then(res => { %s(res.data ?? []); setLoading(false); })\n", setterName)
			b.WriteString("      .catch(() => setLoading(false));\n")
		} else {
			b.WriteString("    // TODO: replace with a dedicated API endpoint\n")
			fmt.Fprintf(&b, "    request('GET', '/api/%s')\n", toKebabCase(varName))
			fmt.Fprintf(&b, "      .then(res => { %s(res.data ?? []); setLoading(false); })\n", setterName)
			b.WriteString("      .catch(() => setLoading(false));\n")
		}
		b.WriteString("  }, []);\n")
	}

	// Collect loop field names for the primary model
	loopFields := collectLoopFields(page, ctx)

	// Return JSX
	b.WriteString("\n  return (\n")
	fmt.Fprintf(&b, "    <div className=\"%s-page\">\n", toKebabCase(page.Name))

	// Auto-generate loading guard when data state exists but no explicit
	// "while loading" condition is declared — avoids unused-variable errors.
	if needsDataState && !hasLoadingCondition {
		b.WriteString("      {loading && <div className=\"loading-spinner\"><div className=\"spinner\" /></div>}\n")
	}

	loopRendered := false
	for _, a := range page.Content {
		if a.Type == "loop" && loopRendered {
			// Skip duplicate loop actions — fields already merged into first loop
			fmt.Fprintf(&b, "      {/* %s */}\n", a.Text)
			continue
		}
		if a.Type == "loop" {
			loopRendered = true
			writeLoopJSX(&b, a.Text, "      ", ctx, loopFields)
			continue
		}
		writePageAction(&b, a, "      ", ctx)
	}

	// Conditional form modal when showForm is toggled
	if needsFormState {
		b.WriteString("      {showForm && (\n")
		b.WriteString("        <div className=\"modal-overlay\" onClick={() => setShowForm(false)}>\n")
		b.WriteString("          <div className=\"modal\" onClick={(ev) => ev.stopPropagation()}>\n")
		b.WriteString("            <button className=\"modal-close\" onClick={() => setShowForm(false)}>×</button>\n")
		if modelName != "" {
			fmt.Fprintf(&b, "            <h2>New %s</h2>\n", modelName)
		}
		b.WriteString("            {/* TODO: form fields */}\n")
		b.WriteString("          </div>\n")
		b.WriteString("        </div>\n")
		b.WriteString("      )}\n")
	}

	b.WriteString("    </div>\n")
	b.WriteString("  );\n")
	b.WriteString("}\n")

	return b.String()
}

// writePageAction maps an IR action to JSX elements.
func writePageAction(b *strings.Builder, a *ir.Action, indent string, ctx *pageContext) {
	switch a.Type {
	case "display":
		writeDisplayJSX(b, a.Text, indent, ctx)
	case "input":
		writeInputJSX(b, a.Text, indent, ctx)
	case "interact":
		writeInteractJSX(b, a.Text, indent, ctx)
	case "condition":
		writeConditionJSX(b, a.Text, indent, ctx)
	case "loop":
		writeLoopJSX(b, a.Text, indent, ctx, nil)
	case "query":
		// Queries handled by useEffect — no JSX needed
	default:
		fmt.Fprintf(b, "%s{/* TODO: %s */}\n", indent, a.Text)
	}
}

// ── Display JSX ──

func writeDisplayJSX(b *strings.Builder, text string, indent string, ctx *pageContext) {
	// Strip leading "show " / "display " from display action text
	cleaned := text
	lowerCleaned := strings.ToLower(cleaned)
	for _, prefix := range []string{"show ", "display "} {
		if strings.HasPrefix(lowerCleaned, prefix) {
			cleaned = cleaned[len(prefix):]
			break
		}
	}
	lower := strings.ToLower(cleaned)

	// Hero section
	if strings.Contains(lower, "hero section") {
		appName := ctx.appName
		if appName == "" {
			appName = "Welcome"
		}
		fmt.Fprintf(b, "%s<section className=\"hero\">\n", indent)
		fmt.Fprintf(b, "%s  <h1>%s</h1>\n", indent, appName)
		fmt.Fprintf(b, "%s  <p>Get things done, beautifully.</p>\n", indent)
		fmt.Fprintf(b, "%s</section>\n", indent)
		return
	}

	// Summary card
	if strings.Contains(lower, "summary card") || (strings.Contains(lower, "summary") && strings.Contains(lower, "with")) {
		metrics := extractMetricLabels(cleaned)
		fmt.Fprintf(b, "%s<div className=\"summary-cards\">\n", indent)
		for _, m := range metrics {
			fmt.Fprintf(b, "%s  <div className=\"stat-card\">\n", indent)
			fmt.Fprintf(b, "%s    <span className=\"stat-value\">0</span>\n", indent)
			fmt.Fprintf(b, "%s    <span className=\"stat-label\">%s</span>\n", indent, capitalize(m))
			fmt.Fprintf(b, "%s  </div>\n", indent)
		}
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Greeting
	if strings.Contains(lower, "greeting") {
		fmt.Fprintf(b, "%s<h2 className=\"greeting\">Welcome back!</h2>\n", indent)
		return
	}

	// Explicit button display: 'show a "Get Started" button'
	if strings.Contains(lower, "button") {
		label := extractQuotedText(cleaned)
		if label == "" {
			label = extractButtonPurpose(lower)
		}
		fmt.Fprintf(b, "%s<button className=\"btn\">%s</button>\n", indent, label)
		return
	}

	// "X as a badge" or "X as a colored badge"
	if strings.Contains(lower, "as a badge") || strings.Contains(lower, "as a colored badge") {
		expr := resolveFieldExpr(cleaned, ctx)
		fmt.Fprintf(b, "%s<span className=\"badge\">{%s}</span>\n", indent, expr)
		return
	}

	// "X in bold"
	if strings.Contains(lower, "in bold") {
		expr := resolveFieldExpr(cleaned, ctx)
		fmt.Fprintf(b, "%s<strong>{%s}</strong>\n", indent, expr)
		return
	}

	// "X with an icon"
	if strings.Contains(lower, "with an icon") {
		expr := resolveFieldExpr(cleaned, ctx)
		fmt.Fprintf(b, "%s<span className=\"with-icon\">{%s}</span>\n", indent, expr)
		return
	}

	// "list of X" — container only, items come from loop actions
	if strings.Contains(lower, "list of") {
		fmt.Fprintf(b, "%s{/* %s — rendered by data loop below */}\n", indent, text)
		return
	}

	// Field list: "the user's name, email, and avatar"
	if strings.Contains(lower, "'s ") {
		fields := extractFieldList(cleaned)
		if len(fields) > 0 {
			fmt.Fprintf(b, "%s<div className=\"field-group\">\n", indent)
			for _, f := range fields {
				fmt.Fprintf(b, "%s  <div className=\"field\"><span className=\"field-label\">%s</span></div>\n", indent, capitalize(f))
			}
			fmt.Fprintf(b, "%s</div>\n", indent)
			return
		}
	}

	// Account/date display (before relative format since "account creation date" is meta text)
	if strings.HasPrefix(lower, "account ") {
		// Strip "like X" examples
		display := cleaned
		if idx := strings.Index(strings.ToLower(display), " like "); idx != -1 {
			display = strings.TrimSpace(display[:idx])
		}
		fmt.Fprintf(b, "%s<p className=\"meta\">%s</p>\n", indent, display)
		return
	}

	// "X in relative format" or "X in red"
	if strings.Contains(lower, "relative format") {
		expr := resolveFieldExpr(cleaned, ctx)
		fmt.Fprintf(b, "%s<time>{%s}</time>\n", indent, expr)
		return
	}
	if strings.Contains(lower, "in red") {
		expr := resolveFieldExpr(cleaned, ctx)
		fmt.Fprintf(b, "%s<span className=\"text-danger\">{%s}</span>\n", indent, expr)
		return
	}

	// Navigation / navbar
	if strings.Contains(lower, "navigation") || strings.Contains(lower, "navbar") || strings.Contains(lower, "nav bar") || strings.Contains(lower, "menu bar") {
		fmt.Fprintf(b, "%s<nav className=\"navbar\">\n", indent)
		fmt.Fprintf(b, "%s  <a href=\"/\">Home</a>\n", indent)
		fmt.Fprintf(b, "%s  <a href=\"/about\">About</a>\n", indent)
		fmt.Fprintf(b, "%s  <a href=\"/contact\">Contact</a>\n", indent)
		fmt.Fprintf(b, "%s</nav>\n", indent)
		return
	}

	// Footer
	if strings.Contains(lower, "footer") {
		appName := ctx.appName
		if appName == "" {
			appName = "App"
		}
		fmt.Fprintf(b, "%s<footer className=\"site-footer\">\n", indent)
		fmt.Fprintf(b, "%s  <p>&copy; 2026 %s. All rights reserved.</p>\n", indent, appName)
		fmt.Fprintf(b, "%s</footer>\n", indent)
		return
	}

	// Modal / dialog / popup
	if strings.Contains(lower, "modal") || strings.Contains(lower, "dialog") || strings.Contains(lower, "popup") {
		fmt.Fprintf(b, "%s<div className=\"modal-overlay\">\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"modal\">\n", indent)
		fmt.Fprintf(b, "%s    <button className=\"modal-close\">&times;</button>\n", indent)
		fmt.Fprintf(b, "%s    <div className=\"modal-body\">{/* TODO: modal content */}</div>\n", indent)
		fmt.Fprintf(b, "%s  </div>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Tabs
	if strings.Contains(lower, "tabs") || strings.Contains(lower, "tab group") || strings.Contains(lower, "tabbed") {
		fmt.Fprintf(b, "%s<div className=\"tabs\">\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"tab-buttons\">\n", indent)
		fmt.Fprintf(b, "%s    <button className=\"tab-btn active\">Tab 1</button>\n", indent)
		fmt.Fprintf(b, "%s    <button className=\"tab-btn\">Tab 2</button>\n", indent)
		fmt.Fprintf(b, "%s    <button className=\"tab-btn\">Tab 3</button>\n", indent)
		fmt.Fprintf(b, "%s  </div>\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"tab-panel\">{/* TODO: active tab content */}</div>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Accordion / collapsible
	if strings.Contains(lower, "accordion") || strings.Contains(lower, "collapsible") || strings.Contains(lower, "expandable") {
		fmt.Fprintf(b, "%s<div className=\"accordion\">\n", indent)
		fmt.Fprintf(b, "%s  <details>\n", indent)
		fmt.Fprintf(b, "%s    <summary>Section 1</summary>\n", indent)
		fmt.Fprintf(b, "%s    <div className=\"accordion-content\">{/* TODO: content */}</div>\n", indent)
		fmt.Fprintf(b, "%s  </details>\n", indent)
		fmt.Fprintf(b, "%s  <details>\n", indent)
		fmt.Fprintf(b, "%s    <summary>Section 2</summary>\n", indent)
		fmt.Fprintf(b, "%s    <div className=\"accordion-content\">{/* TODO: content */}</div>\n", indent)
		fmt.Fprintf(b, "%s  </details>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Progress bar
	if strings.Contains(lower, "progress bar") || strings.Contains(lower, "progress indicator") {
		fmt.Fprintf(b, "%s<div className=\"progress-bar\">\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"progress-fill\" style={{ width: '0%%' }} />\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Toast / alert / notification
	if strings.Contains(lower, "notification") || strings.Contains(lower, "toast") || strings.Contains(lower, "alert banner") {
		fmt.Fprintf(b, "%s<div className=\"alert alert-info\" role=\"alert\">\n", indent)
		fmt.Fprintf(b, "%s  <span>{/* TODO: notification message */}</span>\n", indent)
		fmt.Fprintf(b, "%s  <button className=\"alert-dismiss\">&times;</button>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Avatar / profile picture
	if strings.Contains(lower, "avatar") || strings.Contains(lower, "profile picture") || strings.Contains(lower, "user icon") {
		fmt.Fprintf(b, "%s<div className=\"avatar\">\n", indent)
		fmt.Fprintf(b, "%s  <img src=\"\" alt=\"avatar\" className=\"avatar-img\" onError={(e) => { (e.target as HTMLImageElement).style.display = 'none' }} />\n", indent)
		fmt.Fprintf(b, "%s  <span className=\"avatar-fallback\">U</span>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Breadcrumb
	if strings.Contains(lower, "breadcrumb") {
		fmt.Fprintf(b, "%s<nav className=\"breadcrumbs\">\n", indent)
		fmt.Fprintf(b, "%s  <a href=\"/\">Home</a>\n", indent)
		fmt.Fprintf(b, "%s  <span className=\"separator\">/</span>\n", indent)
		fmt.Fprintf(b, "%s  <span className=\"current\">Current Page</span>\n", indent)
		fmt.Fprintf(b, "%s</nav>\n", indent)
		return
	}

	// Pagination
	if strings.Contains(lower, "pagination") || strings.Contains(lower, "page controls") {
		fmt.Fprintf(b, "%s<nav className=\"pagination\">\n", indent)
		fmt.Fprintf(b, "%s  <button className=\"page-btn\" disabled>&laquo; Prev</button>\n", indent)
		fmt.Fprintf(b, "%s  <span className=\"page-number\">1</span>\n", indent)
		fmt.Fprintf(b, "%s  <button className=\"page-btn\">Next &raquo;</button>\n", indent)
		fmt.Fprintf(b, "%s</nav>\n", indent)
		return
	}

	// Chart / graph / visualization
	if strings.Contains(lower, "chart") || strings.Contains(lower, "graph") || strings.Contains(lower, "visualization") {
		fmt.Fprintf(b, "%s<div className=\"chart-container\">\n", indent)
		fmt.Fprintf(b, "%s  {/* TODO: integrate charting library (e.g. recharts, chart.js) */}\n", indent)
		fmt.Fprintf(b, "%s  <p className=\"chart-placeholder\">Chart placeholder</p>\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
		return
	}

	// Generic "the X" — single field display
	if strings.HasPrefix(lower, "the ") {
		expr := resolveFieldExpr(cleaned, ctx)
		if expr != "null" {
			fmt.Fprintf(b, "%s<p>{%s}</p>\n", indent, expr)
			return
		}
	}

	// Fallback: styled placeholder with TODO instead of raw text
	fmt.Fprintf(b, "%s{/* TODO: %s */}\n", indent, text)
	fmt.Fprintf(b, "%s<div className=\"%s\" />\n", indent, slugify(text))
}

// ── Input JSX ──

func writeInputJSX(b *strings.Builder, text string, indent string, ctx *pageContext) {
	lower := strings.ToLower(text)

	if strings.Contains(lower, "search") {
		fmt.Fprintf(b, "%s<input type=\"search\" placeholder=\"Search...\" className=\"search-input\" onChange={() => {/* TODO: filter */}} />\n", indent)
	} else if strings.Contains(lower, "dropdown") || strings.Contains(lower, "select") {
		label := "All"
		if strings.Contains(lower, "status") {
			label = "All Statuses"
		} else if strings.Contains(lower, "priority") {
			label = "All Priorities"
		}
		fmt.Fprintf(b, "%s<select className=\"filter-select\" onChange={() => {/* TODO: filter */}}>\n", indent)
		fmt.Fprintf(b, "%s  <option value=\"\">%s</option>\n", indent, label)
		fmt.Fprintf(b, "%s</select>\n", indent)
	} else if strings.Contains(lower, "date") && (strings.Contains(lower, "picker") || strings.Contains(lower, "range")) {
		fmt.Fprintf(b, "%s<input type=\"date\" className=\"date-filter\" onChange={() => {/* TODO: filter */}} />\n", indent)
	} else if strings.Contains(lower, "floating button") || strings.Contains(lower, "fab") {
		label := "+"
		if strings.Contains(lower, "add") || strings.Contains(lower, "new") || strings.Contains(lower, "create") {
			label = "+ New"
		}
		fmt.Fprintf(b, "%s<button className=\"fab\" onClick={() => setShowForm(true)}>%s</button>\n", indent, label)
	} else if strings.Contains(lower, "form to") {
		writeFormJSX(b, text, indent, ctx)
	} else if strings.Contains(lower, "file upload") {
		label := "Upload file"
		if strings.Contains(lower, "avatar") {
			label = "Upload avatar"
		}
		fmt.Fprintf(b, "%s<div className=\"file-upload\">\n", indent)
		fmt.Fprintf(b, "%s  <label>%s</label>\n", indent, label)
		fmt.Fprintf(b, "%s  <input type=\"file\" accept=\"image/*\" onChange={() => {/* TODO: handle upload */}} />\n", indent)
		fmt.Fprintf(b, "%s</div>\n", indent)
	} else if strings.Contains(lower, "button") {
		label := extractQuotedText(text)
		if label == "" {
			label = extractButtonPurpose(lower)
		}
		fmt.Fprintf(b, "%s<button className=\"btn\">%s</button>\n", indent, label)
	} else {
		fmt.Fprintf(b, "%s<input type=\"text\" placeholder=\"%s\" />\n", indent, text)
	}
}

// writeFormJSX generates a form with input fields.
func writeFormJSX(b *strings.Builder, text string, indent string, ctx *pageContext) {
	lower := strings.ToLower(text)
	fields := extractFormFields(lower, ctx)

	submitHandler := "/* TODO: submit */"
	if ctx.hasSuccessState && ctx.hasErrorState {
		submitHandler = "setError(''); setSuccess('Saved successfully')"
	}
	fmt.Fprintf(b, "%s<form className=\"form\" onSubmit={(ev) => { ev.preventDefault(); %s }}>\n", indent, submitHandler)
	for _, f := range fields {
		inputType := "text"
		if strings.Contains(f, "email") {
			inputType = "email"
		} else if strings.Contains(f, "password") {
			inputType = "password"
		}
		fmt.Fprintf(b, "%s  <div className=\"form-field\">\n", indent)
		fmt.Fprintf(b, "%s    <label>%s</label>\n", indent, capitalize(f))
		fmt.Fprintf(b, "%s    <input type=\"%s\" name=\"%s\" placeholder=\"%s\" />\n", indent, inputType, f, capitalize(f))
		fmt.Fprintf(b, "%s  </div>\n", indent)
	}
	fmt.Fprintf(b, "%s  <button type=\"submit\">Save</button>\n", indent)
	fmt.Fprintf(b, "%s</form>\n", indent)
}

// ── Loop JSX ──

func writeLoopJSX(b *strings.Builder, text string, indent string, ctx *pageContext, fields []string) {
	lower := strings.ToLower(text)

	dataVar := ctx.varName
	if dataVar == "" {
		dataVar = "data"
	}
	item := ctx.itemVar
	if item == "" {
		item = "item"
	}

	// "each X as a ComponentName" — render component
	if strings.Contains(lower, " as a ") || strings.Contains(lower, " as ") {
		compName := extractComponentRef(text)
		if compName != "" {
			fmt.Fprintf(b, "%s{%s.map((%s) => (\n", indent, dataVar, item)
			fmt.Fprintf(b, "%s  <%s key={%s.id} %s={%s} />\n", indent, compName, item, item, item)
			fmt.Fprintf(b, "%s))}\n", indent)
			return
		}
	}

	// Render with fields
	if len(fields) == 0 {
		fields = extractLoopFields(text, ctx)
	}

	fmt.Fprintf(b, "%s{%s.map((%s) => (\n", indent, dataVar, item)
	fmt.Fprintf(b, "%s  <div key={%s.id} className=\"%s-item\">\n", indent, item, toKebabCase(ctx.modelName))
	if len(fields) > 0 {
		for _, f := range fields {
			fieldExpr := item + "." + f
			if f == "status" || f == "role" || f == "priority" {
				fmt.Fprintf(b, "%s    <span className=\"badge\">{%s}</span>\n", indent, fieldExpr)
			} else if f == "title" || f == "name" {
				fmt.Fprintf(b, "%s    <h3>{%s}</h3>\n", indent, fieldExpr)
			} else if strings.Contains(f, "date") || f == "due" || f == "created" {
				fmt.Fprintf(b, "%s    <time>{%s}</time>\n", indent, fieldExpr)
			} else {
				fmt.Fprintf(b, "%s    <span>{%s}</span>\n", indent, fieldExpr)
			}
		}
	} else {
		fmt.Fprintf(b, "%s    <span>{JSON.stringify(%s)}</span>\n", indent, item)
	}
	fmt.Fprintf(b, "%s  </div>\n", indent)
	fmt.Fprintf(b, "%s))}\n", indent)
}

// ── Condition JSX ──

func writeConditionJSX(b *strings.Builder, text string, indent string, ctx *pageContext) {
	lower := strings.ToLower(text)

	dataVar := ctx.varName
	if dataVar == "" {
		dataVar = "data"
	}

	// Loading state
	if strings.Contains(lower, "while loading") || strings.Contains(lower, "is loading") {
		fmt.Fprintf(b, "%s{loading && (\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"loading-spinner\">\n", indent)
		fmt.Fprintf(b, "%s    <div className=\"spinner\" />\n", indent)
		fmt.Fprintf(b, "%s  </div>\n", indent)
		fmt.Fprintf(b, "%s)}\n", indent)
		return
	}

	// Empty state
	if strings.Contains(lower, "if no ") || strings.Contains(lower, "if there are no") {
		message := extractQuotedText(text)
		if message == "" {
			// Try extracting message after "show " in condition
			message = extractConditionMessage(text)
		}
		if message == "" {
			message = "No items found."
		}
		fmt.Fprintf(b, "%s{!loading && %s.length === 0 && (\n", indent, dataVar)
		fmt.Fprintf(b, "%s  <div className=\"empty-state\">%s</div>\n", indent, message)
		fmt.Fprintf(b, "%s)}\n", indent)
		return
	}

	// Auth conditions
	if strings.Contains(lower, "not logged in") || strings.Contains(lower, "is not logged in") {
		content := extractConditionContent(text)
		fmt.Fprintf(b, "%s{!isLoggedIn && (\n", indent)
		fmt.Fprintf(b, "%s  <div className=\"auth-prompt\">\n", indent)
		writeConditionButtons(b, content, indent+"    ", ctx)
		fmt.Fprintf(b, "%s  </div>\n", indent)
		fmt.Fprintf(b, "%s)}\n", indent)
		return
	}
	if strings.Contains(lower, "is logged in") || strings.Contains(lower, "logged in") {
		content := extractConditionContent(text)
		fmt.Fprintf(b, "%s{isLoggedIn && (\n", indent)
		fmt.Fprintf(b, "%s  <div>\n", indent)
		writeConditionButtons(b, content, indent+"    ", ctx)
		fmt.Fprintf(b, "%s  </div>\n", indent)
		fmt.Fprintf(b, "%s)}\n", indent)
		return
	}

	// Success state
	if strings.Contains(lower, "succeed") || strings.Contains(lower, "success") {
		message := extractQuotedText(text)
		if message == "" {
			message = extractConditionMessage(text)
		}
		if message == "" {
			message = "Success!"
		}
		fmt.Fprintf(b, "%s{success && <div className=\"alert alert-success\">{success || '%s'}</div>}\n", indent, message)
		return
	}

	// Error state
	if strings.Contains(lower, "error") {
		fmt.Fprintf(b, "%s{error && <div className=\"alert alert-error\">{error}</div>}\n", indent)
		return
	}

	// Component-level condition: "if task is overdue, show X in red"
	if strings.Contains(lower, "overdue") {
		expr := resolveFieldExpr(text, ctx)
		fmt.Fprintf(b, "%s{/* %s */}\n", indent, text)
		if expr != "null" {
			fmt.Fprintf(b, "%s<span className=\"text-danger\">{%s}</span>\n", indent, expr)
		}
		return
	}

	// Generic condition — render as comment with placeholder
	fmt.Fprintf(b, "%s{/* TODO: %s */}\n", indent, text)
}

// writeConditionButtons renders buttons extracted from condition content.
func writeConditionButtons(b *strings.Builder, content string, indent string, ctx *pageContext) {
	lower := strings.ToLower(content)

	// Try to find quoted button labels
	labels := extractAllQuotedText(content)
	if len(labels) > 0 {
		for _, label := range labels {
			target := toKebabCase(label)
			if strings.Contains(strings.ToLower(label), "dashboard") {
				target = "dashboard"
			}
			fmt.Fprintf(b, "%s<button onClick={() => navigate('/%s')}>%s</button>\n", indent, target, label)
		}
		return
	}

	// Look for "login and signup buttons" pattern
	if strings.Contains(lower, "login") && strings.Contains(lower, "signup") {
		fmt.Fprintf(b, "%s<button onClick={() => navigate('/login')}>Log In</button>\n", indent)
		fmt.Fprintf(b, "%s<button onClick={() => navigate('/sign-up')}>Sign Up</button>\n", indent)
		return
	}

	// "Go to Dashboard button" → render as a button with navigation
	if strings.Contains(lower, "button") {
		label := extractButtonPurpose(lower)
		target := ""
		for _, word := range strings.Fields(lower) {
			if word != "go" && word != "to" && word != "button" && word != "the" && word != "a" {
				target = word
				break
			}
		}
		if target == "" {
			target = "home"
		}
		fmt.Fprintf(b, "%s<button onClick={() => navigate('/%s')}>%s</button>\n", indent, toKebabCase(target), label)
		return
	}

	// Fallback
	fmt.Fprintf(b, "%s<p>%s</p>\n", indent, content)
}

// ── Interaction JSX ──

func writeInteractJSX(b *strings.Builder, text string, indent string, ctx *pageContext) {
	lower := strings.ToLower(text)

	if strings.Contains(lower, "clicking") || strings.Contains(lower, "click") {
		label := extractButtonLabel(text)

		// Navigate
		if strings.Contains(lower, "navigate") {
			target := extractNavTarget(text)
			fmt.Fprintf(b, "%s<button onClick={() => navigate('/%s')}>%s</button>\n", indent, toKebabCase(target), label)
			return
		}

		// Opens a form
		if strings.Contains(lower, "opens a form") || strings.Contains(lower, "open a form") {
			fmt.Fprintf(b, "%s<button onClick={() => setShowForm(true)}>%s</button>\n", indent, capitalize(label))
			return
		}

		// Triggers onClick (component level)
		if strings.Contains(lower, "triggers") || strings.Contains(lower, "on_click") || strings.Contains(lower, "onclick") {
			fmt.Fprintf(b, "%s{/* clicking triggers onClick — handled by component wrapper */}\n", indent)
			return
		}

		// "clicking Save updates ..." — submit-style button
		if strings.Contains(lower, "update") || strings.Contains(lower, "save") {
			quoted := extractQuotedText(text)
			if quoted != "" {
				label = quoted
			} else if label == "Click" {
				label = "Save"
			}
			handler := "/* TODO: save */"
			if ctx.hasSuccessState && ctx.hasErrorState {
				handler = "setError(''); setSuccess('Saved successfully')"
			} else if ctx.hasSuccessState {
				handler = "setSuccess('Saved successfully')"
			}
			fmt.Fprintf(b, "%s<button onClick={() => { %s }}>%s</button>\n", indent, handler, label)
			return
		}

		// "clicking X opens Y" — render as button if label is multi-word, else comment
		if strings.Contains(lower, "opens") {
			// Single-word labels like "task" are probably item click handlers, not separate buttons
			if label != "Click" && strings.Contains(label, " ") {
				fmt.Fprintf(b, "%s<button onClick={() => {/* TODO: open */}}>%s</button>\n", indent, label)
			} else {
				fmt.Fprintf(b, "%s{/* %s — handled by item click handler */}\n", indent, text)
			}
			return
		}

		// Default click
		fmt.Fprintf(b, "%s<button onClick={() => {/* TODO */}}>%s</button>\n", indent, label)
		return
	}

	// Non-click interactions: drag, scroll, etc.
	fmt.Fprintf(b, "%s{/* TODO: %s */}\n", indent, text)
}

// ── Helpers ──

// detectPageModel finds the primary data model from query/loop actions.
func detectPageModel(page *ir.Page, app *ir.Application) (modelName, varName, itemVar string) {
	for _, a := range page.Content {
		if a.Type == "query" || a.Type == "loop" {
			for _, m := range app.Data {
				lowerText := strings.ToLower(a.Text)
				lowerModel := strings.ToLower(m.Name)
				if strings.Contains(lowerText, lowerModel+"s") || strings.Contains(lowerText, lowerModel) {
					return m.Name, strings.ToLower(pluralize(m.Name)), strings.ToLower(m.Name)
				}
			}
		}
	}
	return "", "data", "item"
}

// findListEndpoint finds an API endpoint that lists items for the given model.
func findListEndpoint(app *ir.Application, modelName string) *ir.Endpoint {
	if modelName == "" {
		return nil
	}
	lowerModel := strings.ToLower(modelName)
	// Priority 1: "ListTasks" or "ListTask"
	for i := range app.APIs {
		lower := strings.ToLower(app.APIs[i].Name)
		if strings.HasPrefix(lower, "list") && strings.Contains(lower, lowerModel) {
			return app.APIs[i]
		}
	}
	// Priority 2: "GetTasks"
	for i := range app.APIs {
		lower := strings.ToLower(app.APIs[i].Name)
		if strings.HasPrefix(lower, "get") && strings.Contains(lower, lowerModel) {
			return app.APIs[i]
		}
	}
	return nil
}

// detectUsedComponents scans page actions for component references (e.g. "as a TaskCard").
func detectUsedComponents(page *ir.Page) []string {
	seen := make(map[string]bool)
	for _, a := range page.Content {
		if a.Type == "loop" {
			if ref := extractComponentRef(a.Text); ref != "" {
				seen[ref] = true
			}
		}
	}
	sorted := make([]string, 0, len(seen))
	for k := range seen {
		sorted = append(sorted, k)
	}
	sort.Strings(sorted)
	return sorted
}

// findModel looks up a data model by name.
func findModel(app *ir.Application, name string) *ir.DataModel {
	for _, m := range app.Data {
		if strings.EqualFold(m.Name, name) {
			return m
		}
	}
	return nil
}

// collectLoopFields merges field references from all loop actions for the primary model.
func collectLoopFields(page *ir.Page, ctx *pageContext) []string {
	seen := map[string]bool{}
	var fields []string
	for _, a := range page.Content {
		if a.Type == "loop" {
			for _, f := range extractLoopFields(a.Text, ctx) {
				if !seen[f] {
					seen[f] = true
					fields = append(fields, f)
				}
			}
		}
	}
	return fields
}

// extractLoopFields extracts field names from loop text like
// "each task shows its title, status, priority, and due date".
func extractLoopFields(text string, ctx *pageContext) []string {
	lower := strings.ToLower(text)

	// Find "shows its ..." or "shows the ..."
	for _, marker := range []string{"shows its ", "shows the ", "shows "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			rest := text[idx+len(marker):]
			return parseFieldNames(rest, ctx)
		}
	}
	return nil
}

// parseFieldNames splits "title, status, priority, and due date" into resolved field names.
func parseFieldNames(text string, ctx *pageContext) []string {
	// Remove trailing modifiers
	for _, mod := range []string{" as a colored badge", " as a badge", " in bold", " with an icon"} {
		text = strings.Replace(strings.ToLower(text), mod, "", -1)
	}
	// Split by comma and "and"
	text = strings.ReplaceAll(text, " and ", ", ")
	parts := strings.Split(text, ",")
	var fields []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}
		resolved := resolveFieldName(p, ctx)
		if resolved != "" {
			fields = append(fields, resolved)
		}
	}
	return fields
}

// resolveFieldName maps a natural language field reference to an actual model field name.
func resolveFieldName(name string, ctx *pageContext) string {
	name = strings.TrimSpace(strings.ToLower(name))
	model := findModel(ctx.app, ctx.modelName)
	if model == nil {
		return toCamelCase(name)
	}

	// Direct match
	for _, f := range model.Fields {
		if strings.ToLower(f.Name) == name {
			return f.Name
		}
	}
	// Match name + type: "due date" → field "due" with type "date"
	for _, f := range model.Fields {
		if strings.ToLower(f.Name+" "+f.Type) == name {
			return f.Name
		}
	}
	// Partial match: "title" in "its title"
	for _, f := range model.Fields {
		if strings.Contains(name, strings.ToLower(f.Name)) {
			return f.Name
		}
	}
	return toCamelCase(name)
}

// resolveFieldExpr resolves a display text into a JS expression like "task.title".
func resolveFieldExpr(text string, ctx *pageContext) string {
	lower := strings.ToLower(text)

	// Remove "like X" examples first (e.g., "like joined 3 months ago")
	stripped := lower
	if idx := strings.Index(stripped, " like "); idx != -1 {
		stripped = stripped[:idx]
	}
	// Strip common modifiers
	for _, mod := range []string{
		"in bold", "as a colored badge", "as a badge", "with an icon",
		"in relative format", "in red", "the ", "show ",
	} {
		stripped = strings.Replace(stripped, mod, " ", -1)
	}
	stripped = strings.TrimSpace(stripped)

	// Component prop resolution: "the task title" → task.title
	for propName, propType := range ctx.props {
		propLower := strings.ToLower(propName)
		if strings.Contains(stripped, propLower+" ") {
			fieldPart := strings.TrimSpace(strings.Replace(stripped, propLower+" ", "", 1))
			fieldPart = strings.TrimSpace(strings.TrimPrefix(fieldPart, "its "))
			model := findModel(ctx.app, propType)
			if model != nil {
				for _, f := range model.Fields {
					if strings.Contains(fieldPart, strings.ToLower(f.Name)) {
						return propName + "." + f.Name
					}
					if strings.ToLower(f.Name+" "+f.Type) == fieldPart {
						return propName + "." + f.Name
					}
				}
			}
			return propName + "." + toCamelCase(fieldPart)
		}
		// Just the field name: "the status" where prop is task:Task
		if model := findModel(ctx.app, propType); model != nil {
			for _, f := range model.Fields {
				if strings.Contains(stripped, strings.ToLower(f.Name)) {
					return propName + "." + f.Name
				}
			}
		}
	}

	// Page-level: "the user's name" → extract field from model context
	if strings.Contains(lower, "'s ") {
		return "null /* TODO: resolve field */"
	}

	// Page item variable
	if ctx.itemVar != "" {
		fieldName := resolveFieldName(stripped, ctx)
		if fieldName != "" {
			return ctx.itemVar + "." + fieldName
		}
	}

	return "null"
}

// extractQuotedText extracts the first quoted string from text.
// "show a \"Get Started\" button" → "Get Started"
func extractQuotedText(text string) string {
	if idx := strings.Index(text, "\""); idx != -1 {
		rest := text[idx+1:]
		if end := strings.Index(rest, "\""); end != -1 {
			return rest[:end]
		}
	}
	return ""
}

// extractAllQuotedText extracts all quoted strings from text.
func extractAllQuotedText(text string) []string {
	var results []string
	remaining := text
	for {
		idx := strings.Index(remaining, "\"")
		if idx == -1 {
			break
		}
		rest := remaining[idx+1:]
		end := strings.Index(rest, "\"")
		if end == -1 {
			break
		}
		results = append(results, rest[:end])
		remaining = rest[end+1:]
	}
	return results
}

// extractButtonPurpose derives a button label from display text.
func extractButtonPurpose(lower string) string {
	// "a get started button" → "Get Started"
	lower = strings.TrimPrefix(lower, "a ")
	lower = strings.TrimPrefix(lower, "an ")
	lower = strings.TrimSuffix(lower, " button")
	lower = strings.TrimSuffix(lower, " buttons")
	words := strings.Fields(lower)
	for i := range words {
		words[i] = capitalize(words[i])
	}
	if len(words) == 0 {
		return "Click"
	}
	return strings.Join(words, " ")
}

// extractMetricLabels extracts metric names from "with total tasks, completed tasks, and overdue tasks".
func extractMetricLabels(text string) []string {
	lower := strings.ToLower(text)
	// Find "with ..."
	idx := strings.Index(lower, "with ")
	if idx == -1 {
		return []string{"Total"}
	}
	rest := text[idx+5:]
	rest = strings.ReplaceAll(rest, " and ", ", ")
	parts := strings.Split(rest, ",")
	var labels []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			labels = append(labels, p)
		}
	}
	if len(labels) == 0 {
		return []string{"Total"}
	}
	return labels
}

// extractFieldList extracts field names from "the user's name, email, and avatar".
func extractFieldList(text string) []string {
	lower := strings.ToLower(text)
	// Find "'s " marker
	idx := strings.Index(lower, "'s ")
	if idx == -1 {
		return nil
	}
	rest := text[idx+3:]
	rest = strings.ReplaceAll(rest, " and ", ", ")
	parts := strings.Split(rest, ",")
	var fields []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			fields = append(fields, p)
		}
	}
	return fields
}

// extractFormFields extracts field names for a form from context.
func extractFormFields(lower string, ctx *pageContext) []string {
	// "a form to update name and bio" → [name, bio]
	for _, marker := range []string{"form to update ", "form to create ", "form to edit "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			rest := lower[idx+len(marker):]
			// Check if it references a model: "a form to create a Task"
			if strings.HasPrefix(rest, "a ") || strings.HasPrefix(rest, "an ") {
				rest = strings.TrimPrefix(rest, "a ")
				rest = strings.TrimPrefix(rest, "an ")
				modelName := strings.TrimSpace(rest)
				model := findModel(ctx.app, modelName)
				if model != nil {
					var fields []string
					for _, f := range model.Fields {
						fl := strings.ToLower(f.Name)
						if fl == "created" || fl == "updated" || fl == "createdat" || fl == "updatedat" {
							continue
						}
						if f.Encrypted {
							continue
						}
						fields = append(fields, f.Name)
					}
					return fields
				}
			}
			// Direct field names: "update name and bio"
			rest = strings.ReplaceAll(rest, " and ", ", ")
			parts := strings.Split(rest, ",")
			var fields []string
			for _, p := range parts {
				p = strings.TrimSpace(p)
				if p != "" {
					fields = append(fields, p)
				}
			}
			return fields
		}
	}
	return []string{"field"}
}

// extractComponentRef extracts a component name from "each task as a TaskCard".
func extractComponentRef(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{" as a ", " as "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			rest := strings.TrimSpace(text[idx+len(marker):])
			// Take the first word and ensure it's PascalCase (component name)
			if space := strings.IndexByte(rest, ' '); space != -1 {
				rest = rest[:space]
			}
			if len(rest) > 0 && rest[0] >= 'A' && rest[0] <= 'Z' {
				return rest
			}
		}
	}
	return ""
}

// extractConditionMessage extracts a display message from condition text.
// "if no tasks match, show No tasks found. Create your first task!" → "No tasks found. Create your first task!"
func extractConditionMessage(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{", show ", " show "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			msg := strings.TrimSpace(text[idx+len(marker):])
			// Skip if it's a UI element reference (e.g., "show a spinner")
			msgLower := strings.ToLower(msg)
			if strings.HasPrefix(msgLower, "a ") || strings.HasPrefix(msgLower, "an ") || strings.HasPrefix(msgLower, "the ") {
				return ""
			}
			return msg
		}
	}
	return ""
}

// extractConditionContent extracts content after "show" in condition text.
func extractConditionContent(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{", show ", " show "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			return strings.TrimSpace(text[idx+len(marker):])
		}
	}
	return text
}

// capitalize returns the string with its first letter uppercased.
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// slugify converts text to a CSS-friendly class name.
func slugify(s string) string {
	var result []rune
	for _, r := range strings.ToLower(s) {
		if r >= 'a' && r <= 'z' || r >= '0' && r <= '9' {
			result = append(result, r)
		} else if r == ' ' || r == '-' || r == '_' {
			if len(result) > 0 && result[len(result)-1] != '-' {
				result = append(result, '-')
			}
		}
	}
	if len(result) > 0 && result[len(result)-1] == '-' {
		result = result[:len(result)-1]
	}
	return string(result)
}

// extractButtonLabel extracts a reasonable button label from action text.
func extractButtonLabel(text string) string {
	// Try quoted text first
	if q := extractQuotedText(text); q != "" {
		return q
	}
	lower := strings.ToLower(text)
	// "clicking the X button navigates to Y" → "X"
	if idx := strings.Index(lower, "clicking the "); idx != -1 {
		after := text[idx+len("clicking the "):]
		if end := strings.Index(strings.ToLower(after), " button"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " navigates"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " opens"); end != -1 {
			return after[:end]
		}
		if end := strings.Index(strings.ToLower(after), " updates"); end != -1 {
			return after[:end]
		}
	}
	// "clicking a task" → "task"
	if idx := strings.Index(lower, "clicking a "); idx != -1 {
		after := text[idx+len("clicking a "):]
		if space := strings.IndexByte(after, ' '); space != -1 {
			return after[:space]
		}
		return after
	}
	// "clicking Save updates ..." → "Save"
	if idx := strings.Index(lower, "clicking "); idx != -1 {
		after := text[idx+len("clicking "):]
		// Take words until a verb (updates, opens, navigates, triggers)
		words := strings.Fields(after)
		var labelParts []string
		for _, w := range words {
			wl := strings.ToLower(w)
			if wl == "updates" || wl == "opens" || wl == "navigates" || wl == "triggers" {
				break
			}
			labelParts = append(labelParts, w)
		}
		if len(labelParts) > 0 {
			return strings.Join(labelParts, " ")
		}
	}
	return "Click"
}

// extractNavTarget extracts the navigation target page name from action text.
func extractNavTarget(text string) string {
	lower := strings.ToLower(text)
	for _, marker := range []string{"navigates to ", "navigate to ", "go to "} {
		if idx := strings.Index(lower, marker); idx != -1 {
			target := strings.TrimSpace(text[idx+len(marker):])
			if space := strings.IndexByte(target, ' '); space != -1 {
				target = target[:space]
			}
			return target
		}
	}
	return "home"
}
