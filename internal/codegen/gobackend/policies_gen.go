package gobackend

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generatePolicies produces middleware/policies.go with role → permission/restriction maps.
func generatePolicies(moduleName string, app *ir.Application) string {
	var sb strings.Builder
	sb.WriteString(`package middleware

// Generated by Human compiler — do not edit

// PolicyRule represents a single permission or restriction rule.
type PolicyRule struct {
	Action    string
	Model     string
	Scope     string // "own", "any", "all", or ""
	Limit     int
	Period    string
	Condition string
}

// PolicyDefinition defines a role's complete set of permissions and restrictions.
type PolicyDefinition struct {
	Name         string
	Permissions  []PolicyRule
	Restrictions []PolicyRule
}

// Policies maps role names to their policy definitions.
var Policies = map[string]PolicyDefinition{
`)

	for _, pol := range app.Policies {
		fmt.Fprintf(&sb, "\t%q: {\n", pol.Name)
		fmt.Fprintf(&sb, "\t\tName: %q,\n", pol.Name)

		// Permissions
		sb.WriteString("\t\tPermissions: []PolicyRule{\n")
		for _, perm := range pol.Permissions {
			r := parsePolicyRule(perm.Text)
			fmt.Fprintf(&sb, "\t\t\t{Action: %q, Model: %q, Scope: %q", r.action, r.model, r.scope)
			if r.limit > 0 {
				fmt.Fprintf(&sb, ", Limit: %d", r.limit)
			}
			if r.period != "" {
				fmt.Fprintf(&sb, ", Period: %q", r.period)
			}
			if r.condition != "" {
				fmt.Fprintf(&sb, ", Condition: %q", r.condition)
			}
			sb.WriteString("},\n")
		}
		sb.WriteString("\t\t},\n")

		// Restrictions
		sb.WriteString("\t\tRestrictions: []PolicyRule{\n")
		for _, rest := range pol.Restrictions {
			r := parsePolicyRule(rest.Text)
			fmt.Fprintf(&sb, "\t\t\t{Action: %q, Model: %q, Scope: %q", r.action, r.model, r.scope)
			if r.limit > 0 {
				fmt.Fprintf(&sb, ", Limit: %d", r.limit)
			}
			if r.period != "" {
				fmt.Fprintf(&sb, ", Period: %q", r.period)
			}
			if r.condition != "" {
				fmt.Fprintf(&sb, ", Condition: %q", r.condition)
			}
			sb.WriteString("},\n")
		}
		sb.WriteString("\t\t},\n")

		sb.WriteString("\t},\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

// generateAuthorize produces middleware/authorize.go with a Gin middleware factory.
func generateAuthorizeMiddleware(moduleName string, app *ir.Application) string {
	return `package middleware

// Generated by Human compiler — do not edit

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

// Authorize returns a Gin middleware that checks the user's role against defined policies.
//
// Usage:
//
//	api.POST("/tasks", middleware.RequireAuth(db, cfg), middleware.Authorize("create", "task"), handlers.CreateTask(db, cfg))
//
// Behavior:
//  1. If a restriction matches the action+model → 403 denied
//  2. If a permission matches → allowed (scope attached to context)
//  3. If no rule matches → allowed (no policy opinion)
func Authorize(action string, model string) gin.HandlerFunc {
	return func(c *gin.Context) {
		role, exists := c.Get("userRole")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role assigned"})
			c.Abort()
			return
		}

		roleStr, ok := role.(string)
		if !ok || roleStr == "" {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role assigned"})
			c.Abort()
			return
		}

		policy, found := Policies[roleStr]
		if !found {
			// No policy defined for this role — allow by default
			c.Next()
			return
		}

		// Check restrictions first (deny takes precedence)
		for _, r := range policy.Restrictions {
			if r.Action == action && (r.Model == model || r.Model == "*") {
				c.JSON(http.StatusForbidden, gin.H{
					"error": fmt.Sprintf("%s cannot %s %s", roleStr, action, model),
				})
				c.Abort()
				return
			}
		}

		// Check permissions — attach scope for downstream query filtering
		for _, r := range policy.Permissions {
			if r.Action == action && (r.Model == model || r.Model == "*") {
				if r.Scope == "own" {
					c.Set("authzScope", "own")
				}
				break
			}
		}

		// No matching rule — allow by default (policy has no opinion)
		c.Next()
	}
}
`
}

// goParsedRule is a lightweight parsed representation for Go codegen.
type goParsedRule struct {
	action    string
	model     string
	scope     string
	limit     int
	period    string
	condition string
}

// parsePolicyRule extracts structured info from a policy rule's raw text.
func parsePolicyRule(text string) goParsedRule {
	lower := strings.ToLower(strings.TrimSpace(text))
	words := strings.Fields(lower)

	r := goParsedRule{}
	if len(words) == 0 {
		return r
	}

	r.action = words[0]

	// Scope detection
	switch {
	case strings.Contains(lower, "only their own"):
		r.scope = "own"
	case strings.Contains(lower, "any of their own"):
		r.scope = "own"
	case goContainsWord(words, "any"):
		r.scope = "any"
	case goContainsWord(words, "all"):
		r.scope = "all"
	}

	// Extract model — look for nouns after scope words or action
	skip := map[string]bool{
		"only": true, "their": true, "own": true, "any": true, "all": true,
		"of": true, "the": true, "a": true, "an": true, "and": true,
		"system": true, "up": true, "to": true, "per": true, "unlimited": true,
		"that": true, "which": true, "where": true, "are": true, "is": true,
	}
	for i := len(words) - 1; i >= 1; i-- {
		w := words[i]
		if skip[w] || w == r.action {
			continue
		}
		r.model = goSingularize(w)
		break
	}

	return r
}

func goSingularize(word string) string {
	if word == "data" || word == "analytics" {
		return word
	}
	if strings.HasSuffix(word, "ies") && len(word) > 3 {
		return word[:len(word)-3] + "y"
	}
	if strings.HasSuffix(word, "ses") || strings.HasSuffix(word, "xes") {
		return word[:len(word)-2]
	}
	if strings.HasSuffix(word, "s") && !strings.HasSuffix(word, "ss") && len(word) > 1 {
		return word[:len(word)-1]
	}
	return word
}

func goContainsWord(words []string, target string) bool {
	for _, w := range words {
		if w == target {
			return true
		}
	}
	return false
}
