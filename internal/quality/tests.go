package quality

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateTests creates Jest test files for each API endpoint.
// Returns (fileCount, testCount, error).
func generateTests(app *ir.Application, testDir string) (int, int, error) {
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return 0, 0, err
	}

	totalFiles := 0
	totalTests := 0

	for _, ep := range app.APIs {
		content, testCount := generateEndpointTests(ep, app)
		filename := toKebabCase(ep.Name) + ".test.ts"
		path := filepath.Join(testDir, filename)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return 0, 0, err
		}
		totalFiles++
		totalTests += testCount
	}

	return totalFiles, totalTests, nil
}

// generateEndpointTests produces a Jest test file for a single endpoint.
// Returns the file content and the number of test cases.
func generateEndpointTests(ep *ir.Endpoint, app *ir.Application) (string, int) {
	var b strings.Builder
	testCount := 0

	b.WriteString("// Generated by Human compiler â€” do not edit\n\n")
	b.WriteString("import request from 'supertest';\n")
	b.WriteString("import { app } from '../server';\n\n")

	method := httpMethod(ep.Name)
	path := apiPath(ep.Name)

	fmt.Fprintf(&b, "describe('%s %s', () => {\n", strings.ToUpper(method), path)

	// 1. Happy path test
	writeHappyPathTest(&b, ep, method, path)
	testCount++

	// 2. Auth required test (if endpoint requires auth)
	if ep.Auth {
		writeAuthRequiredTest(&b, method, path)
		testCount++
	}

	// 3. Validation error tests (one per validation rule)
	for _, v := range ep.Validation {
		writeValidationTest(&b, ep, v, method, path)
		testCount++
	}

	// 4. Not found / empty result test for GET endpoints
	if strings.ToUpper(method) == "GET" {
		writeNotFoundTest(&b, method, path)
		testCount++
	}

	b.WriteString("});\n")

	return b.String(), testCount
}

func writeHappyPathTest(b *strings.Builder, ep *ir.Endpoint, method, path string) {
	fmt.Fprintf(b, "  it('should succeed with valid request', async () => {\n")

	if len(ep.Params) > 0 && strings.ToUpper(method) != "GET" {
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		if ep.Auth {
			b.WriteString("      .set('Authorization', 'Bearer test-token')\n")
		}
		b.WriteString("      .send({\n")
		for _, p := range ep.Params {
			name := sanitizeParamName(p.Name)
			fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
		}
		b.WriteString("      });\n")
	} else {
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')", method, path)
		if ep.Auth {
			b.WriteString("\n      .set('Authorization', 'Bearer test-token')")
		}
		b.WriteString(";\n")
	}

	b.WriteString("\n    expect(response.status).toBeLessThan(500);\n")
	b.WriteString("  });\n\n")
}

func writeAuthRequiredTest(b *strings.Builder, method, path string) {
	fmt.Fprintf(b, "  it('should return 401 without auth token', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .%s('%s');\n\n", method, path)
	b.WriteString("    expect(response.status).toBe(401);\n")
	b.WriteString("    expect(response.body.error).toBeDefined();\n")
	b.WriteString("  });\n\n")
}

func writeValidationTest(b *strings.Builder, ep *ir.Endpoint, v *ir.ValidationRule, method, path string) {
	desc := validationTestDesc(v)
	fmt.Fprintf(b, "  it('%s', async () => {\n", desc)

	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .%s('%s')\n", method, path)
	if ep.Auth {
		b.WriteString("      .set('Authorization', 'Bearer test-token')\n")
	}
	b.WriteString("      .send({\n")

	// Send invalid data for this specific field
	for _, p := range ep.Params {
		name := sanitizeParamName(p.Name)
		if name == sanitizeParamName(v.Field) {
			fmt.Fprintf(b, "        %s: %s,\n", name, invalidValue(v))
		} else {
			fmt.Fprintf(b, "        %s: 'valid-%s',\n", name, name)
		}
	}

	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBe(400);\n")
	b.WriteString("    expect(response.body.error).toBeDefined();\n")
	b.WriteString("  });\n\n")
}

func writeNotFoundTest(b *strings.Builder, method, path string) {
	fmt.Fprintf(b, "  it('should handle empty results', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .%s('%s')\n", method, path)
	b.WriteString("      .set('Authorization', 'Bearer test-token');\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(500);\n")
	b.WriteString("  });\n\n")
}

// validationTestDesc generates a human-readable test description for a validation rule.
func validationTestDesc(v *ir.ValidationRule) string {
	switch v.Rule {
	case "not_empty":
		return fmt.Sprintf("should reject empty %s", v.Field)
	case "valid_email":
		return fmt.Sprintf("should reject invalid %s", v.Field)
	case "min_length":
		return fmt.Sprintf("should reject %s shorter than %s characters", v.Field, v.Value)
	case "max_length":
		return fmt.Sprintf("should reject %s longer than %s characters", v.Field, v.Value)
	case "unique":
		return fmt.Sprintf("should reject duplicate %s", v.Field)
	case "future_date":
		return fmt.Sprintf("should reject past %s", v.Field)
	case "matches":
		return fmt.Sprintf("should reject mismatched %s", v.Field)
	default:
		return fmt.Sprintf("should validate %s", v.Field)
	}
}

// invalidValue returns a JS literal that should fail the given validation.
func invalidValue(v *ir.ValidationRule) string {
	switch v.Rule {
	case "not_empty":
		return "''"
	case "valid_email":
		return "'not-an-email'"
	case "min_length":
		return "'x'"
	case "max_length":
		return "'" + strings.Repeat("x", 300) + "'"
	case "unique":
		return "'existing@example.com'"
	case "future_date":
		return "'2020-01-01'"
	default:
		return "'invalid'"
	}
}

// httpMethod infers HTTP method from endpoint name.
func httpMethod(name string) string {
	lower := strings.ToLower(name)
	switch {
	case strings.HasPrefix(lower, "get"):
		return "get"
	case strings.HasPrefix(lower, "delete"):
		return "delete"
	case strings.HasPrefix(lower, "update"):
		return "put"
	default:
		return "post"
	}
}

// apiPath infers REST path from endpoint name.
func apiPath(name string) string {
	stripped := name
	for _, prefix := range []string{"Get", "Create", "Update", "Delete"} {
		if strings.HasPrefix(name, prefix) && len(name) > len(prefix) {
			stripped = name[len(prefix):]
			break
		}
	}
	return "/api/" + toKebabCase(stripped)
}

// sanitizeParamName ensures valid JS identifier.
func sanitizeParamName(name string) string {
	if !strings.Contains(name, " ") {
		return name
	}
	return toCamelCase(strings.ReplaceAll(name, " ", "_"))
}
