package quality

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateIntegrationTests creates a single integration test file with e2e flow tests.
// Returns (testCount, error).
func generateIntegrationTests(app *ir.Application, testDir string) (int, error) {
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return 0, err
	}

	var b strings.Builder
	testCount := 0

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import request from 'supertest';\n")
	b.WriteString("import { app } from '../server';\n\n")

	b.WriteString("let authToken: string;\n\n")

	b.WriteString("beforeAll(async () => {\n")
	b.WriteString("  // Database setup — connect and seed test data\n")
	b.WriteString("});\n\n")

	b.WriteString("afterAll(async () => {\n")
	b.WriteString("  // Database teardown — clean up test data\n")
	b.WriteString("});\n\n")

	// Auth flow
	testCount += writeAuthFlow(&b, app)

	// CRUD cycles
	for _, model := range app.Data {
		testCount += writeCRUDCycle(&b, model, app)
	}

	// Auth rejection tests
	testCount += writeAuthRejectionTests(&b, app)

	if testCount == 0 {
		return 0, nil
	}

	path := filepath.Join(testDir, "integration.test.ts")
	if err := os.WriteFile(path, []byte(b.String()), 0644); err != nil {
		return 0, err
	}

	return testCount, nil
}

// writeAuthFlow generates SignUp → Login → authenticated action tests.
// Only generated if both SignUp and Login endpoints exist.
// Returns the number of tests written.
func writeAuthFlow(b *strings.Builder, app *ir.Application) int {
	signUp := findEndpoint(app, "SignUp")
	login := findEndpoint(app, "Login")
	if signUp == nil || login == nil {
		return 0
	}

	count := 0

	b.WriteString("describe('Authentication flow', () => {\n")

	// SignUp test
	b.WriteString("  it('should sign up a new user', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .post('%s')\n", apiPath(signUp.Name))
	b.WriteString("      .send({\n")
	for _, p := range signUp.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("  });\n\n")
	count++

	// Login test
	b.WriteString("  it('should login and receive token', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .post('%s')\n", apiPath(login.Name))
	b.WriteString("      .send({\n")
	for _, p := range login.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("    expect(response.body.token).toBeDefined();\n")
	b.WriteString("    authToken = response.body.token;\n")
	b.WriteString("  });\n\n")
	count++

	// Authenticated action — use the first auth-required endpoint
	for _, ep := range app.APIs {
		if ep.Auth {
			method := httpMethod(ep.Name)
			path := apiPath(ep.Name)
			fmt.Fprintf(b, "  it('should access %s with auth token', async () => {\n", ep.Name)
			b.WriteString("    const response = await request(app)\n")
			fmt.Fprintf(b, "      .%s('%s')\n", method, path)
			b.WriteString("      .set('Authorization', `Bearer ${authToken}`);\n\n")
			b.WriteString("    expect(response.status).toBeLessThan(500);\n")
			b.WriteString("  });\n\n")
			count++
			break
		}
	}

	b.WriteString("});\n\n")
	return count
}

// writeCRUDCycle generates Create → Read → Update → Delete tests for a model.
// Only generated if the model has at least Create + one other CRUD endpoint.
// Returns the number of tests written.
func writeCRUDCycle(b *strings.Builder, model *ir.DataModel, app *ir.Application) int {
	createEP := findEndpoint(app, "Create"+model.Name)
	if createEP == nil {
		return 0
	}

	// Check for at least one other CRUD endpoint
	getEP := findEndpoint(app, "Get"+model.Name)
	getListEP := findEndpoint(app, "Get"+model.Name+"s")
	updateEP := findEndpoint(app, "Update"+model.Name)
	deleteEP := findEndpoint(app, "Delete"+model.Name)

	if getEP == nil && getListEP == nil && updateEP == nil && deleteEP == nil {
		return 0
	}

	count := 0

	fmt.Fprintf(b, "describe('%s CRUD cycle', () => {\n", model.Name)
	fmt.Fprintf(b, "  let createdId: string;\n\n")

	// Create
	fmt.Fprintf(b, "  it('should create a %s', async () => {\n", model.Name)
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(createEP.Name), apiPath(createEP.Name))
	b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
	b.WriteString("      .send({\n")
	for _, p := range createEP.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("    createdId = response.body.id;\n")
	b.WriteString("  });\n\n")
	count++

	// Read
	readEP := getEP
	if readEP == nil {
		readEP = getListEP
	}
	if readEP != nil {
		fmt.Fprintf(b, "  it('should read %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(readEP.Name), apiPath(readEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`);\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	// Update
	if updateEP != nil {
		fmt.Fprintf(b, "  it('should update %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(updateEP.Name), apiPath(updateEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		b.WriteString("      .send({\n")
		b.WriteString("        id: createdId,\n")
		for _, p := range updateEP.Params {
			name := sanitizeParamName(p.Name)
			if name == "id" {
				continue
			}
			fmt.Fprintf(b, "        %s: 'updated-%s',\n", name, name)
		}
		b.WriteString("      });\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	// Delete
	if deleteEP != nil {
		fmt.Fprintf(b, "  it('should delete %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(deleteEP.Name), apiPath(deleteEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		b.WriteString("      .send({ id: createdId });\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// writeAuthRejectionTests generates tests that call protected endpoints without tokens.
// Returns the number of tests written.
func writeAuthRejectionTests(b *strings.Builder, app *ir.Application) int {
	authEndpoints := 0
	for _, ep := range app.APIs {
		if ep.Auth {
			authEndpoints++
		}
	}
	if authEndpoints == 0 {
		return 0
	}

	count := 0

	b.WriteString("describe('Auth rejection', () => {\n")

	for _, ep := range app.APIs {
		if !ep.Auth {
			continue
		}
		method := httpMethod(ep.Name)
		path := apiPath(ep.Name)
		fmt.Fprintf(b, "  it('should reject unauthenticated %s', async () => {\n", ep.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s');\n\n", method, path)
		b.WriteString("    expect(response.status).toBe(401);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// findEndpoint looks up an endpoint by name (case-insensitive).
func findEndpoint(app *ir.Application, name string) *ir.Endpoint {
	for _, ep := range app.APIs {
		if strings.EqualFold(ep.Name, name) {
			return ep
		}
	}
	return nil
}
