package quality

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateIntegrationTests creates a single integration test file with e2e flow tests.
// Returns (testCount, error).
func generateIntegrationTests(app *ir.Application, testDir string) (int, error) {
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return 0, err
	}

	var b strings.Builder
	testCount := 0

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import request from 'supertest';\n")
	b.WriteString("import { app } from '../server';\n\n")

	b.WriteString("let authToken: string;\n\n")

	b.WriteString("beforeAll(async () => {\n")
	b.WriteString("  // Database setup — connect and seed test data\n")
	b.WriteString("});\n\n")

	b.WriteString("afterAll(async () => {\n")
	b.WriteString("  // Database teardown — clean up test data\n")
	b.WriteString("});\n\n")

	// Auth flow
	testCount += writeAuthFlow(&b, app)

	// CRUD cycles
	for _, model := range app.Data {
		testCount += writeCRUDCycle(&b, model, app)
	}

	// Auth rejection tests
	testCount += writeAuthRejectionTests(&b, app)

	// Validation failure tests
	testCount += writeValidationFailureTests(&b, app)

	// Not-found tests
	testCount += writeNotFoundTests(&b, app)

	// Relationship integrity tests
	testCount += writeRelationshipIntegrityTests(&b, app)

	if testCount == 0 {
		return 0, nil
	}

	path := filepath.Join(testDir, "integration.test.ts")
	if err := os.WriteFile(path, []byte(b.String()), 0644); err != nil {
		return 0, err
	}

	return testCount, nil
}

// writeAuthFlow generates SignUp → Login → authenticated action tests.
// Only generated if both SignUp and Login endpoints exist.
// Returns the number of tests written.
func writeAuthFlow(b *strings.Builder, app *ir.Application) int {
	signUp := findEndpoint(app, "SignUp")
	login := findEndpoint(app, "Login")
	if signUp == nil || login == nil {
		return 0
	}

	count := 0

	b.WriteString("describe('Authentication flow', () => {\n")

	// SignUp test
	b.WriteString("  it('should sign up a new user', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .post('%s')\n", apiPath(signUp.Name))
	b.WriteString("      .send({\n")
	for _, p := range signUp.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("  });\n\n")
	count++

	// Login test
	b.WriteString("  it('should login and receive token', async () => {\n")
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .post('%s')\n", apiPath(login.Name))
	b.WriteString("      .send({\n")
	for _, p := range login.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("    expect(response.body.token).toBeDefined();\n")
	b.WriteString("    authToken = response.body.token;\n")
	b.WriteString("  });\n\n")
	count++

	// Authenticated action — use the first auth-required endpoint
	for _, ep := range app.APIs {
		if ep.Auth {
			method := httpMethod(ep.Name)
			path := apiPath(ep.Name)
			fmt.Fprintf(b, "  it('should access %s with auth token', async () => {\n", ep.Name)
			b.WriteString("    const response = await request(app)\n")
			fmt.Fprintf(b, "      .%s('%s')\n", method, path)
			b.WriteString("      .set('Authorization', `Bearer ${authToken}`);\n\n")
			b.WriteString("    expect(response.status).toBeLessThan(500);\n")
			b.WriteString("  });\n\n")
			count++
			break
		}
	}

	b.WriteString("});\n\n")
	return count
}

// writeCRUDCycle generates Create → Read → Update → Delete tests for a model.
// Only generated if the model has at least Create + one other CRUD endpoint.
// Returns the number of tests written.
func writeCRUDCycle(b *strings.Builder, model *ir.DataModel, app *ir.Application) int {
	createEP := findEndpoint(app, "Create"+model.Name)
	if createEP == nil {
		return 0
	}

	// Check for at least one other CRUD endpoint
	getEP := findEndpoint(app, "Get"+model.Name)
	getListEP := findEndpoint(app, "Get"+model.Name+"s")
	updateEP := findEndpoint(app, "Update"+model.Name)
	deleteEP := findEndpoint(app, "Delete"+model.Name)

	if getEP == nil && getListEP == nil && updateEP == nil && deleteEP == nil {
		return 0
	}

	count := 0

	fmt.Fprintf(b, "describe('%s CRUD cycle', () => {\n", model.Name)
	fmt.Fprintf(b, "  let createdId: string;\n\n")

	// Create
	fmt.Fprintf(b, "  it('should create a %s', async () => {\n", model.Name)
	b.WriteString("    const response = await request(app)\n")
	fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(createEP.Name), apiPath(createEP.Name))
	b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
	b.WriteString("      .send({\n")
	for _, p := range createEP.Params {
		name := sanitizeParamName(p.Name)
		fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
	}
	b.WriteString("      });\n\n")
	b.WriteString("    expect(response.status).toBeLessThan(400);\n")
	b.WriteString("    createdId = response.body.id;\n")
	b.WriteString("  });\n\n")
	count++

	// Read
	readEP := getEP
	if readEP == nil {
		readEP = getListEP
	}
	if readEP != nil {
		fmt.Fprintf(b, "  it('should read %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(readEP.Name), apiPath(readEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`);\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	// Update
	if updateEP != nil {
		fmt.Fprintf(b, "  it('should update %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(updateEP.Name), apiPath(updateEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		b.WriteString("      .send({\n")
		b.WriteString("        id: createdId,\n")
		for _, p := range updateEP.Params {
			name := sanitizeParamName(p.Name)
			if name == "id" {
				continue
			}
			fmt.Fprintf(b, "        %s: 'updated-%s',\n", name, name)
		}
		b.WriteString("      });\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	// Delete
	if deleteEP != nil {
		fmt.Fprintf(b, "  it('should delete %s', async () => {\n", model.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", httpMethod(deleteEP.Name), apiPath(deleteEP.Name))
		b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		b.WriteString("      .send({ id: createdId });\n\n")
		b.WriteString("    expect(response.status).toBeLessThan(400);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// writeAuthRejectionTests generates tests that call protected endpoints without tokens.
// Returns the number of tests written.
func writeAuthRejectionTests(b *strings.Builder, app *ir.Application) int {
	authEndpoints := 0
	for _, ep := range app.APIs {
		if ep.Auth {
			authEndpoints++
		}
	}
	if authEndpoints == 0 {
		return 0
	}

	count := 0

	b.WriteString("describe('Auth rejection', () => {\n")

	for _, ep := range app.APIs {
		if !ep.Auth {
			continue
		}
		method := httpMethod(ep.Name)
		path := apiPath(ep.Name)
		fmt.Fprintf(b, "  it('should reject unauthenticated %s', async () => {\n", ep.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s');\n\n", method, path)
		b.WriteString("    expect(response.status).toBe(401);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// writeValidationFailureTests generates tests that send invalid data to endpoints
// with validation rules and expect 400 responses.
func writeValidationFailureTests(b *strings.Builder, app *ir.Application) int {
	// Collect endpoints that have validation rules
	var validatedEPs []*ir.Endpoint
	for _, ep := range app.APIs {
		if len(ep.Validation) > 0 {
			validatedEPs = append(validatedEPs, ep)
		}
	}
	if len(validatedEPs) == 0 {
		return 0
	}

	count := 0

	b.WriteString("describe('Validation failures', () => {\n")

	for _, ep := range validatedEPs {
		method := httpMethod(ep.Name)
		path := apiPath(ep.Name)

		for _, val := range ep.Validation {
			testName := fmt.Sprintf("%s with invalid %s (%s)", ep.Name, val.Field, val.Rule)
			fmt.Fprintf(b, "  it('should reject %s', async () => {\n", testName)
			b.WriteString("    const response = await request(app)\n")
			fmt.Fprintf(b, "      .%s('%s')\n", method, path)
			if ep.Auth {
				b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
			}

			// Send data violating the specific rule
			switch val.Rule {
			case "not_empty":
				fmt.Fprintf(b, "      .send({ %s: '' });\n\n", sanitizeParamName(val.Field))
			case "valid_email":
				fmt.Fprintf(b, "      .send({ %s: 'not-an-email' });\n\n", sanitizeParamName(val.Field))
			case "min_length":
				fmt.Fprintf(b, "      .send({ %s: 'a' });\n\n", sanitizeParamName(val.Field))
			case "max_length":
				fmt.Fprintf(b, "      .send({ %s: '%s' });\n\n", sanitizeParamName(val.Field), strings.Repeat("x", 10000))
			default:
				fmt.Fprintf(b, "      .send({ %s: null });\n\n", sanitizeParamName(val.Field))
			}

			b.WriteString("    expect(response.status).toBe(400);\n")
			b.WriteString("  });\n\n")
			count++
		}
	}

	b.WriteString("});\n\n")
	return count
}

// writeNotFoundTests generates tests that send non-existent IDs to endpoints
// with "fetch" steps and expect 404 responses.
func writeNotFoundTests(b *strings.Builder, app *ir.Application) int {
	var fetchEPs []*ir.Endpoint
	for _, ep := range app.APIs {
		for _, step := range ep.Steps {
			if step.Type == "query" && strings.Contains(strings.ToLower(step.Text), "fetch") {
				fetchEPs = append(fetchEPs, ep)
				break
			}
		}
	}
	if len(fetchEPs) == 0 {
		return 0
	}

	count := 0

	b.WriteString("describe('Not found responses', () => {\n")

	for _, ep := range fetchEPs {
		method := httpMethod(ep.Name)
		path := apiPath(ep.Name)

		fmt.Fprintf(b, "  it('should return 404 for non-existent %s', async () => {\n", ep.Name)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		if ep.Auth {
			b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		}
		b.WriteString("      .send({ id: '999999' });\n\n")
		b.WriteString("    expect(response.status).toBe(404);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// writeRelationshipIntegrityTests generates tests that send invalid parent IDs
// for endpoints creating child records with belongs_to relationships.
func writeRelationshipIntegrityTests(b *strings.Builder, app *ir.Application) int {
	// Find models with belongs_to relationships
	type childEndpoint struct {
		ep     *ir.Endpoint
		parent string
	}
	var children []childEndpoint

	for _, model := range app.Data {
		for _, rel := range model.Relations {
			if rel.Kind == "belongs_to" {
				// Find Create endpoint for this model
				createEP := findEndpoint(app, "Create"+model.Name)
				if createEP != nil {
					children = append(children, childEndpoint{ep: createEP, parent: rel.Target})
				}
			}
		}
	}
	if len(children) == 0 {
		return 0
	}

	count := 0

	b.WriteString("describe('Relationship integrity', () => {\n")

	for _, child := range children {
		method := httpMethod(child.ep.Name)
		path := apiPath(child.ep.Name)

		fmt.Fprintf(b, "  it('should reject %s with invalid %s reference', async () => {\n", child.ep.Name, child.parent)
		b.WriteString("    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		if child.ep.Auth {
			b.WriteString("      .set('Authorization', `Bearer ${authToken}`)\n")
		}
		b.WriteString("      .send({\n")
		for _, p := range child.ep.Params {
			name := sanitizeParamName(p.Name)
			lower := strings.ToLower(p.Name)
			if strings.Contains(lower, strings.ToLower(child.parent)) && strings.Contains(lower, "id") {
				fmt.Fprintf(b, "        %s: '999999-nonexistent',\n", name)
			} else {
				fmt.Fprintf(b, "        %s: 'test-%s',\n", name, name)
			}
		}
		b.WriteString("      });\n\n")
		b.WriteString("    expect(response.status).toBeGreaterThanOrEqual(400);\n")
		b.WriteString("    expect(response.status).toBeLessThan(500);\n")
		b.WriteString("  });\n\n")
		count++
	}

	b.WriteString("});\n\n")
	return count
}

// findEndpoint looks up an endpoint by name (case-insensitive).
func findEndpoint(app *ir.Application, name string) *ir.Endpoint {
	for _, ep := range app.APIs {
		if strings.EqualFold(ep.Name, name) {
			return ep
		}
	}
	return nil
}
