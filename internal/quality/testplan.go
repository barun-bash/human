package quality

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateTestPlan produces a QA test plan document from the IR.
func generateTestPlan(app *ir.Application) string {
	var b strings.Builder

	b.WriteString("# QA Test Plan\n\n")
	fmt.Fprintf(&b, "Application: **%s**\n\n", app.Name)
	b.WriteString("Generated by Human compiler quality engine.\n\n")

	b.WriteString("---\n\n")

	// Page tests
	if len(app.Pages) > 0 {
		b.WriteString("## Page Tests\n\n")
		for _, page := range app.Pages {
			fmt.Fprintf(&b, "### %s\n\n", page.Name)
			writePageTests(&b, page)
		}
	}

	// API tests
	if len(app.APIs) > 0 {
		b.WriteString("## API Tests\n\n")
		for _, ep := range app.APIs {
			fmt.Fprintf(&b, "### %s\n\n", ep.Name)
			writeAPITests(&b, ep, app)
		}
	}

	// Workflow tests
	if len(app.Workflows) > 0 {
		b.WriteString("## Workflow Tests\n\n")
		for _, wf := range app.Workflows {
			fmt.Fprintf(&b, "### Trigger: %s\n\n", wf.Trigger)
			writeWorkflowTests(&b, wf)
		}
	}

	// Cross-cutting tests
	b.WriteString("## Cross-Cutting Tests\n\n")
	writeCrossCuttingTests(&b, app)

	return b.String()
}

// writePageTests generates test cases for a single page.
func writePageTests(b *strings.Builder, page *ir.Page) {
	// Display tests
	b.WriteString("**Display Tests:**\n\n")
	fmt.Fprintf(b, "- [ ] Page %s loads without errors\n", page.Name)

	for _, action := range page.Content {
		switch action.Type {
		case "display":
			fmt.Fprintf(b, "- [ ] Verify: %s\n", action.Text)
		}
	}
	b.WriteString("\n")

	// Interaction tests
	hasInteractions := false
	for _, action := range page.Content {
		if action.Type == "interact" || action.Type == "navigate" || action.Type == "input" {
			if !hasInteractions {
				b.WriteString("**Interaction Tests:**\n\n")
				hasInteractions = true
			}
			fmt.Fprintf(b, "- [ ] Test: %s\n", action.Text)
		}
	}
	if hasInteractions {
		b.WriteString("\n")
	}

	// State tests
	hasConditions := false
	for _, action := range page.Content {
		if action.Type == "condition" {
			if !hasConditions {
				b.WriteString("**State Tests:**\n\n")
				hasConditions = true
			}
			fmt.Fprintf(b, "- [ ] Verify condition handling: %s\n", action.Text)
		}
	}
	if !hasConditions {
		b.WriteString("**State Tests:**\n\n")
	}
	fmt.Fprintf(b, "- [ ] Empty state renders correctly\n")
	fmt.Fprintf(b, "- [ ] Loading state shows indicator\n")
	fmt.Fprintf(b, "- [ ] Error state displays error message\n")
	b.WriteString("\n")

	// Responsive tests
	b.WriteString("**Responsive Tests:**\n\n")
	b.WriteString("- [ ] Desktop (1920x1080) renders correctly\n")
	b.WriteString("- [ ] Tablet (768x1024) renders correctly\n")
	b.WriteString("- [ ] Mobile (375x667) renders correctly\n")
	b.WriteString("\n")
}

// writeAPITests generates test cases for a single API endpoint.
func writeAPITests(b *strings.Builder, ep *ir.Endpoint, app *ir.Application) {
	// Happy path
	b.WriteString("**Happy Path:**\n\n")
	fmt.Fprintf(b, "- [ ] %s succeeds with valid request\n", ep.Name)
	b.WriteString("\n")

	// Validation tests
	if len(ep.Validation) > 0 {
		b.WriteString("**Validation Tests:**\n\n")
		for _, v := range ep.Validation {
			fmt.Fprintf(b, "- [ ] Reject when %s fails %s validation\n", v.Field, v.Rule)
		}
		b.WriteString("\n")
	}

	// Auth tests
	if ep.Auth {
		b.WriteString("**Authentication Tests:**\n\n")
		b.WriteString("- [ ] Returns 401 without auth token\n")
		b.WriteString("- [ ] Returns 401 with expired token\n")
		b.WriteString("- [ ] Returns 401 with invalid token\n")
		b.WriteString("\n")
	}

	// Policy tests
	matchingPolicies := findMatchingPolicies(ep, app)
	if len(matchingPolicies) > 0 {
		b.WriteString("**Authorization Tests:**\n\n")
		for _, policy := range matchingPolicies {
			for _, perm := range policy.Permissions {
				fmt.Fprintf(b, "- [ ] %s role: allowed — %s\n", policy.Name, perm.Text)
			}
			for _, rest := range policy.Restrictions {
				fmt.Fprintf(b, "- [ ] %s role: denied — %s\n", policy.Name, rest.Text)
			}
		}
		b.WriteString("\n")
	}
}

// writeWorkflowTests generates test cases for a workflow.
func writeWorkflowTests(b *strings.Builder, wf *ir.Workflow) {
	fmt.Fprintf(b, "- [ ] Workflow triggers on: %s\n", wf.Trigger)
	for _, step := range wf.Steps {
		fmt.Fprintf(b, "- [ ] Verify step executes: %s\n", step.Text)
	}
	b.WriteString("\n")
}

// writeCrossCuttingTests generates cross-cutting test cases.
func writeCrossCuttingTests(b *strings.Builder, app *ir.Application) {
	// Auth flow
	if app.Auth != nil {
		b.WriteString("**Authentication Flow:**\n\n")
		b.WriteString("- [ ] User can log in with valid credentials\n")
		b.WriteString("- [ ] User is rejected with invalid credentials\n")
		b.WriteString("- [ ] Session/token persists across page navigation\n")
		b.WriteString("- [ ] User can log out\n")
		b.WriteString("\n")
	}

	// Navigation
	if len(app.Pages) > 1 {
		b.WriteString("**Navigation:**\n\n")
		for i := 0; i < len(app.Pages); i++ {
			for _, action := range app.Pages[i].Content {
				if action.Type == "navigate" && action.Value != "" {
					fmt.Fprintf(b, "- [ ] %s → %s navigation works\n", app.Pages[i].Name, action.Value)
				}
			}
		}
		b.WriteString("\n")
	}
}

// findMatchingPolicies returns policies whose rules reference the endpoint's model.
func findMatchingPolicies(ep *ir.Endpoint, app *ir.Application) []*ir.Policy {
	var matches []*ir.Policy
	epLower := strings.ToLower(ep.Name)

	for _, policy := range app.Policies {
		matched := false
		for _, perm := range policy.Permissions {
			if strings.Contains(strings.ToLower(perm.Text), epLower) || referencesEndpointModel(perm.Text, ep) {
				matched = true
				break
			}
		}
		if !matched {
			for _, rest := range policy.Restrictions {
				if strings.Contains(strings.ToLower(rest.Text), epLower) || referencesEndpointModel(rest.Text, ep) {
					matched = true
					break
				}
			}
		}
		if matched {
			matches = append(matches, policy)
		}
	}
	return matches
}

// referencesEndpointModel checks if a policy rule text references the model targeted by an endpoint.
func referencesEndpointModel(ruleText string, ep *ir.Endpoint) bool {
	lower := strings.ToLower(ruleText)
	for _, step := range ep.Steps {
		if step.Target != "" && strings.Contains(lower, strings.ToLower(step.Target)) {
			return true
		}
	}
	return false
}
