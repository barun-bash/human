package quality

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// generateComponentTests creates React Testing Library test files for each page.
// Returns (fileCount, testCount, error).
func generateComponentTests(app *ir.Application, testDir string) (int, int, error) {
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return 0, 0, err
	}

	totalFiles := 0
	totalTests := 0

	for _, page := range app.Pages {
		content, testCount := generatePageTests(page, app)
		filename := toKebabCase(page.Name) + ".test.tsx"
		path := filepath.Join(testDir, filename)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return 0, 0, err
		}
		totalFiles++
		totalTests += testCount
	}

	return totalFiles, totalTests, nil
}

// generatePageTests produces a React Testing Library test file for a single page.
// Returns the file content and the number of test cases.
func generatePageTests(page *ir.Page, app *ir.Application) (string, int) {
	var b strings.Builder
	testCount := 0

	componentName := page.Name
	kebabName := toKebabCase(page.Name)

	b.WriteString("// Generated by Human compiler — do not edit\n\n")
	b.WriteString("import React from 'react';\n")
	b.WriteString("import { render, screen, fireEvent } from '@testing-library/react';\n")
	b.WriteString("import { BrowserRouter } from 'react-router-dom';\n")
	fmt.Fprintf(&b, "import { %s } from '../pages/%s';\n\n", componentName, kebabName)
	b.WriteString("jest.mock('../api/client');\n\n")

	fmt.Fprintf(&b, "const renderPage = () => render(\n")
	fmt.Fprintf(&b, "  <BrowserRouter>\n")
	fmt.Fprintf(&b, "    <%s />\n", componentName)
	fmt.Fprintf(&b, "  </BrowserRouter>\n")
	fmt.Fprintf(&b, ");\n\n")

	fmt.Fprintf(&b, "describe('%s page', () => {\n", componentName)

	// 1. Always: render without crashing
	b.WriteString("  it('should render without crashing', () => {\n")
	b.WriteString("    renderPage();\n")
	b.WriteString("  });\n\n")
	testCount++

	// Scan page content for test opportunities
	for _, action := range page.Content {
		switch action.Type {
		case "display":
			// Extract display text for getByText assertion
			displayText := extractDisplayText(action.Text)
			if displayText != "" {
				fmt.Fprintf(&b, "  it('should display %s', () => {\n", escapeJSString(displayText))
				b.WriteString("    renderPage();\n")
				fmt.Fprintf(&b, "    expect(screen.getByText(/%s/i)).toBeInTheDocument();\n", escapeRegex(displayText))
				b.WriteString("  });\n\n")
				testCount++
			}

		case "condition":
			lower := strings.ToLower(action.Text)
			if strings.Contains(lower, "loading") {
				b.WriteString("  it('should show loading state', () => {\n")
				b.WriteString("    renderPage();\n")
				b.WriteString("    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n")
				b.WriteString("  });\n\n")
				testCount++
			}
			if strings.Contains(lower, "no ") && (strings.Contains(lower, "match") || strings.Contains(lower, "found")) {
				b.WriteString("  it('should show empty state', () => {\n")
				b.WriteString("    renderPage();\n")
				b.WriteString("    expect(screen.getByText(/no .* (match|found)/i)).toBeInTheDocument();\n")
				b.WriteString("  });\n\n")
				testCount++
			}

		case "interact":
			lower := strings.ToLower(action.Text)
			if strings.Contains(lower, "clicking") || strings.Contains(lower, "click") {
				buttonText := extractClickTarget(action.Text)
				if buttonText != "" {
					fmt.Fprintf(&b, "  it('should handle clicking %s', () => {\n", escapeJSString(buttonText))
					b.WriteString("    renderPage();\n")
					fmt.Fprintf(&b, "    const button = screen.getByText(/%s/i);\n", escapeRegex(buttonText))
					b.WriteString("    fireEvent.click(button);\n")
					b.WriteString("  });\n\n")
					testCount++
				}
			}
		}
	}

	b.WriteString("});\n")

	return b.String(), testCount
}

// extractDisplayText pulls the meaningful text from a display action.
// e.g., "show welcome message" → "welcome message"
func extractDisplayText(text string) string {
	lower := strings.ToLower(text)
	for _, prefix := range []string{"show ", "display ", "render "} {
		if strings.HasPrefix(lower, prefix) {
			return text[len(prefix):]
		}
	}
	return text
}

// extractClickTarget pulls the button/element name from an interact action.
// e.g., "clicking the delete button" → "delete"
func extractClickTarget(text string) string {
	lower := strings.ToLower(text)
	// Remove common prefixes
	for _, prefix := range []string{"clicking the ", "clicking ", "click the ", "click on ", "click "} {
		if strings.HasPrefix(lower, prefix) {
			rest := text[len(prefix):]
			// Remove trailing "button", "link", etc.
			rest = strings.TrimSuffix(strings.TrimSuffix(rest, " button"), " link")
			return rest
		}
	}
	return ""
}

// escapeJSString escapes a string for use in a JS string literal.
func escapeJSString(s string) string {
	s = strings.ReplaceAll(s, "'", "\\'")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}

// escapeRegex escapes special regex characters for use in a JS regex literal.
// Backslash must be escaped first to avoid double-escaping other replacements.
func escapeRegex(s string) string {
	special := []string{"\\", ".", "*", "+", "?", "(", ")", "[", "]", "{", "}", "^", "$", "|"}
	result := s
	for _, ch := range special {
		result = strings.ReplaceAll(result, ch, "\\"+ch)
	}
	return result
}
