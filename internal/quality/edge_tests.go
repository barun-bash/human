package quality

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// edgeCase represents a single edge case test payload.
type edgeCase struct {
	Label   string // test description
	Value   string // JS literal to send
	Expect  int    // expected HTTP status (400 for invalid, 200/201 for valid)
}

// generateEdgeTests creates edge case validation test files for data models
// that have a matching Create endpoint.
// Returns (fileCount, testCount, error).
func generateEdgeTests(app *ir.Application, testDir string) (int, int, error) {
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return 0, 0, err
	}

	totalFiles := 0
	totalTests := 0

	for _, model := range app.Data {
		if !hasCreateEndpoint(app, model.Name) {
			continue
		}
		content, testCount := generateModelEdgeTests(model, app)
		if testCount == 0 {
			continue
		}
		filename := toKebabCase(model.Name) + ".edge.test.ts"
		path := filepath.Join(testDir, filename)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return 0, 0, err
		}
		totalFiles++
		totalTests += testCount
	}

	return totalFiles, totalTests, nil
}

// generateModelEdgeTests produces edge case tests for a single data model.
// Returns the file content and the number of test cases.
func generateModelEdgeTests(model *ir.DataModel, app *ir.Application) (string, int) {
	var b strings.Builder
	testCount := 0

	endpoint := fmt.Sprintf("Create%s", model.Name)
	method := httpMethod(endpoint)
	path := apiPath(endpoint)

	b.WriteString("// Generated by Human compiler â€” do not edit\n\n")
	b.WriteString("import request from 'supertest';\n")
	b.WriteString("import { app } from '../server';\n\n")

	fmt.Fprintf(&b, "describe('%s edge cases', () => {\n", model.Name)

	for _, field := range model.Fields {
		testCount += writeFieldEdgeTests(&b, field, method, path)
	}

	b.WriteString("});\n")

	return b.String(), testCount
}

// writeFieldEdgeTests writes edge case tests for one field.
// Returns the number of tests written.
func writeFieldEdgeTests(b *strings.Builder, field *ir.DataField, method, path string) int {
	count := 0
	payloads := edgePayloadsForType(field.Type)

	for _, ec := range payloads {
		desc := fmt.Sprintf("%s: %s", field.Name, ec.Label)
		fmt.Fprintf(b, "  it('should handle %s', async () => {\n", escapeJSString(desc))
		fmt.Fprintf(b, "    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
		fmt.Fprintf(b, "      .send({ %s: %s });\n\n", toCamelCase(field.Name), ec.Value)
		fmt.Fprintf(b, "    expect(response.status).toBe(%d);\n", ec.Expect)
		fmt.Fprintf(b, "  });\n\n")
		count++
	}

	// Enum-specific tests
	if field.Type == "enum" && len(field.EnumValues) > 0 {
		// Valid enum values should succeed
		for _, val := range field.EnumValues {
			fmt.Fprintf(b, "  it('should accept valid enum %s = %s', async () => {\n", field.Name, val)
			fmt.Fprintf(b, "    const response = await request(app)\n")
			fmt.Fprintf(b, "      .%s('%s')\n", method, path)
			fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
			fmt.Fprintf(b, "      .send({ %s: '%s' });\n\n", toCamelCase(field.Name), val)
			fmt.Fprintf(b, "    expect(response.status).toBeLessThan(500);\n")
			fmt.Fprintf(b, "  });\n\n")
			count++
		}
		// Invalid enum value
		fmt.Fprintf(b, "  it('should reject invalid enum %s', async () => {\n", field.Name)
		fmt.Fprintf(b, "    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
		fmt.Fprintf(b, "      .send({ %s: 'INVALID_ENUM_VALUE' });\n\n", toCamelCase(field.Name))
		fmt.Fprintf(b, "    expect(response.status).toBe(400);\n")
		fmt.Fprintf(b, "  });\n\n")
		count++
	}

	// Required field tests
	if field.Required {
		// null
		fmt.Fprintf(b, "  it('should reject null %s', async () => {\n", field.Name)
		fmt.Fprintf(b, "    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
		fmt.Fprintf(b, "      .send({ %s: null });\n\n", toCamelCase(field.Name))
		fmt.Fprintf(b, "    expect(response.status).toBe(400);\n")
		fmt.Fprintf(b, "  });\n\n")
		count++

		// undefined
		fmt.Fprintf(b, "  it('should reject undefined %s', async () => {\n", field.Name)
		fmt.Fprintf(b, "    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
		fmt.Fprintf(b, "      .send({ %s: undefined });\n\n", toCamelCase(field.Name))
		fmt.Fprintf(b, "    expect(response.status).toBe(400);\n")
		fmt.Fprintf(b, "  });\n\n")
		count++

		// omitted field
		fmt.Fprintf(b, "  it('should reject missing %s', async () => {\n", field.Name)
		fmt.Fprintf(b, "    const response = await request(app)\n")
		fmt.Fprintf(b, "      .%s('%s')\n", method, path)
		fmt.Fprintf(b, "      .set('Authorization', 'Bearer test-token')\n")
		fmt.Fprintf(b, "      .send({});\n\n")
		fmt.Fprintf(b, "    expect(response.status).toBe(400);\n")
		fmt.Fprintf(b, "  });\n\n")
		count++
	}

	return count
}

// edgePayloadsForType returns test payloads for a given field type.
func edgePayloadsForType(fieldType string) []edgeCase {
	switch fieldType {
	case "text":
		return []edgeCase{
			{Label: "empty string", Value: "''", Expect: 400},
			{Label: "very long string", Value: "'" + strings.Repeat("a", 10000) + "'", Expect: 400},
			{Label: "special characters", Value: `"<>&\\\"\\/"`, Expect: 400},
			{Label: "XSS payload", Value: "'<script>alert(1)</script>'", Expect: 400},
			{Label: "SQL injection", Value: `"'; DROP TABLE users; --"`, Expect: 400},
		}
	case "email":
		return []edgeCase{
			{Label: "empty email", Value: "''", Expect: 400},
			{Label: "missing @", Value: "'invalidemail.com'", Expect: 400},
			{Label: "missing domain", Value: "'user@'", Expect: 400},
			{Label: "missing local part", Value: "'@example.com'", Expect: 400},
			{Label: "double @", Value: "'user@@example.com'", Expect: 400},
		}
	case "date", "datetime":
		return []edgeCase{
			{Label: "empty date", Value: "''", Expect: 400},
			{Label: "invalid format", Value: "'not-a-date'", Expect: 400},
			{Label: "epoch zero", Value: "'1970-01-01T00:00:00Z'", Expect: 400},
			{Label: "far future", Value: "'9999-12-31T23:59:59Z'", Expect: 400},
		}
	case "number":
		return []edgeCase{
			{Label: "negative number", Value: "-1", Expect: 400},
			{Label: "zero", Value: "0", Expect: 400},
			{Label: "very large number", Value: "999999999999", Expect: 400},
			{Label: "string instead of number", Value: "'not-a-number'", Expect: 400},
		}
	case "decimal":
		return []edgeCase{
			{Label: "negative decimal", Value: "-0.01", Expect: 400},
			{Label: "string instead of decimal", Value: "'not-a-decimal'", Expect: 400},
			{Label: "very large decimal", Value: "999999999.99", Expect: 400},
		}
	case "boolean":
		return []edgeCase{
			{Label: "string instead of boolean", Value: "'true'", Expect: 400},
			{Label: "number instead of boolean", Value: "1", Expect: 400},
		}
	case "url":
		return []edgeCase{
			{Label: "empty url", Value: "''", Expect: 400},
			{Label: "missing protocol", Value: "'example.com'", Expect: 400},
			{Label: "invalid url", Value: "'not://a url'", Expect: 400},
		}
	default:
		return nil
	}
}
