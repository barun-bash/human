package quality

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// VulnerabilityReport holds the results of a dependency vulnerability scan.
type VulnerabilityReport struct {
	Total    int
	Critical int
	High     int
	Moderate int
	Low      int
	Advisories []Advisory
}

// Advisory is a single dependency vulnerability finding.
type Advisory struct {
	Module   string
	Severity string
	Title    string
	URL      string
	Path     string
}

// npmAuditOutput represents the JSON output from `npm audit --json`.
type npmAuditOutput struct {
	Metadata struct {
		Vulnerabilities struct {
			Critical int `json:"critical"`
			High     int `json:"high"`
			Moderate int `json:"moderate"`
			Low      int `json:"low"`
			Total    int `json:"total"`
		} `json:"vulnerabilities"`
	} `json:"metadata"`
	Vulnerabilities map[string]npmVuln `json:"vulnerabilities"`
}

type npmVuln struct {
	Name     string `json:"name"`
	Severity string `json:"severity"`
	Via      []json.RawMessage `json:"via"`
}

type npmViaAdvisory struct {
	Title string `json:"title"`
	URL   string `json:"url"`
	Name  string `json:"name"`
}

// ScanDependencies runs npm audit against the generated package.json.
// Returns nil gracefully if npm is not installed or no package.json exists.
func ScanDependencies(outputDir string) (*VulnerabilityReport, error) {
	// Check for npm
	npmPath, err := exec.LookPath("npm")
	if err != nil {
		return nil, nil // npm not available, skip gracefully
	}

	// Check for package.json
	pkgDir := filepath.Join(outputDir, "node")
	pkgJSON := filepath.Join(pkgDir, "package.json")
	if _, err := os.Stat(pkgJSON); os.IsNotExist(err) {
		return nil, nil // no package.json, skip gracefully
	}

	// Generate package-lock.json (needed for npm audit)
	lockCmd := exec.Command(npmPath, "install", "--package-lock-only", "--prefix", pkgDir)
	lockCmd.Stderr = nil
	lockCmd.Stdout = nil
	_ = lockCmd.Run() // best-effort; audit may still work

	// Clean up generated lock and node_modules after scan
	defer func() {
		os.Remove(filepath.Join(pkgDir, "package-lock.json"))
		os.RemoveAll(filepath.Join(pkgDir, "node_modules"))
	}()

	// Run npm audit
	auditCmd := exec.Command(npmPath, "audit", "--json", "--prefix", pkgDir)
	output, err := auditCmd.Output()

	// npm audit returns non-zero exit code when vulnerabilities are found,
	// but still produces valid JSON. Only fail on truly empty output.
	if len(output) == 0 {
		if err != nil {
			return nil, fmt.Errorf("npm audit failed: %w", err)
		}
		return &VulnerabilityReport{}, nil
	}

	return parseNpmAudit(output)
}

// parseNpmAudit parses the JSON output from npm audit.
func parseNpmAudit(data []byte) (*VulnerabilityReport, error) {
	var audit npmAuditOutput
	if err := json.Unmarshal(data, &audit); err != nil {
		return nil, fmt.Errorf("parsing npm audit output: %w", err)
	}

	report := &VulnerabilityReport{
		Total:    audit.Metadata.Vulnerabilities.Total,
		Critical: audit.Metadata.Vulnerabilities.Critical,
		High:     audit.Metadata.Vulnerabilities.High,
		Moderate: audit.Metadata.Vulnerabilities.Moderate,
		Low:      audit.Metadata.Vulnerabilities.Low,
	}

	for name, vuln := range audit.Vulnerabilities {
		adv := Advisory{
			Module:   name,
			Severity: vuln.Severity,
		}

		// Try to extract advisory details from "via" field
		for _, raw := range vuln.Via {
			var via npmViaAdvisory
			if json.Unmarshal(raw, &via) == nil && via.Title != "" {
				adv.Title = via.Title
				adv.URL = via.URL
				break
			}
		}

		if adv.Title == "" {
			adv.Title = fmt.Sprintf("Vulnerability in %s", name)
		}

		report.Advisories = append(report.Advisories, adv)
	}

	return report, nil
}

// renderDependencyAudit produces a standalone dependency-audit.md.
func renderDependencyAudit(report *VulnerabilityReport) string {
	var b strings.Builder

	b.WriteString("# Dependency Audit\n\n")
	b.WriteString("Generated by Human compiler quality engine.\n\n")

	if report == nil {
		b.WriteString("Dependency scanning was skipped (npm not available or no package.json).\n")
		return b.String()
	}

	fmt.Fprintf(&b, "**Summary:** %d total — %d critical, %d high, %d moderate, %d low\n\n",
		report.Total, report.Critical, report.High, report.Moderate, report.Low)

	if report.Total == 0 {
		b.WriteString("No vulnerabilities found.\n")
		return b.String()
	}

	b.WriteString("## Advisories\n\n")
	b.WriteString("| Module | Severity | Title | URL |\n")
	b.WriteString("|--------|----------|-------|-----|\n")
	for _, a := range report.Advisories {
		url := a.URL
		if url == "" {
			url = "—"
		}
		fmt.Fprintf(&b, "| %s | %s | %s | %s |\n", a.Module, a.Severity, a.Title, url)
	}
	b.WriteString("\n")

	return b.String()
}

// renderDependencySection produces a summary section for the build report.
func renderDependencySection(report *VulnerabilityReport) string {
	var b strings.Builder

	b.WriteString("## Dependencies\n\n")

	if report == nil {
		b.WriteString("Dependency scanning was skipped.\n\n")
		return b.String()
	}

	b.WriteString("| Severity | Count |\n")
	b.WriteString("|----------|-------|\n")
	fmt.Fprintf(&b, "| Critical | %d |\n", report.Critical)
	fmt.Fprintf(&b, "| High | %d |\n", report.High)
	fmt.Fprintf(&b, "| Moderate | %d |\n", report.Moderate)
	fmt.Fprintf(&b, "| Low | %d |\n", report.Low)
	fmt.Fprintf(&b, "| **Total** | **%d** |\n", report.Total)
	b.WriteString("\n")

	return b.String()
}
