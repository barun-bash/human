package quality

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// checkLint scans the IR for code quality issues.
func checkLint(app *ir.Application) []Warning {
	var warnings []Warning

	warnings = append(warnings, checkUnusedModels(app)...)
	warnings = append(warnings, checkEmptyPages(app)...)
	warnings = append(warnings, checkAPIsWithoutValidation(app)...)
	warnings = append(warnings, checkEmptyWorkflows(app)...)

	return warnings
}

// checkUnusedModels flags data models that are never referenced by any API, page, or workflow.
func checkUnusedModels(app *ir.Application) []Warning {
	var warnings []Warning

	for _, model := range app.Data {
		lower := strings.ToLower(model.Name)
		used := false

		// Check API step text for model references
		for _, ep := range app.APIs {
			for _, step := range ep.Steps {
				if strings.Contains(strings.ToLower(step.Text), lower) {
					used = true
					break
				}
				if strings.EqualFold(step.Target, model.Name) {
					used = true
					break
				}
			}
			if used {
				break
			}
			// Check params for model references
			for _, p := range ep.Params {
				if strings.EqualFold(p.Name, model.Name) || strings.Contains(strings.ToLower(p.Name), lower) {
					used = true
					break
				}
			}
			if used {
				break
			}
		}

		// Check pages for model references
		if !used {
			for _, page := range app.Pages {
				for _, action := range page.Content {
					if strings.Contains(strings.ToLower(action.Text), lower) {
						used = true
						break
					}
				}
				if used {
					break
				}
			}
		}

		// Check workflows for model references
		if !used {
			for _, wf := range app.Workflows {
				if strings.Contains(strings.ToLower(wf.Trigger), lower) {
					used = true
					break
				}
				for _, step := range wf.Steps {
					if strings.Contains(strings.ToLower(step.Text), lower) {
						used = true
						break
					}
				}
				if used {
					break
				}
			}
		}

		// Check relations from other models
		if !used {
			for _, other := range app.Data {
				if other.Name == model.Name {
					continue
				}
				for _, rel := range other.Relations {
					if strings.EqualFold(rel.Target, model.Name) || strings.EqualFold(rel.Through, model.Name) {
						used = true
						break
					}
				}
				if used {
					break
				}
			}
		}

		if !used {
			warnings = append(warnings, Warning{
				Category: "unused",
				Message:  fmt.Sprintf("Data model '%s' is not referenced by any API, page, or workflow", model.Name),
				Target:   model.Name,
			})
		}
	}

	return warnings
}

// checkEmptyPages flags pages with no content actions.
func checkEmptyPages(app *ir.Application) []Warning {
	var warnings []Warning

	for _, page := range app.Pages {
		if len(page.Content) == 0 {
			warnings = append(warnings, Warning{
				Category: "empty",
				Message:  fmt.Sprintf("Page '%s' has no content — it will render as a blank page", page.Name),
				Target:   page.Name,
			})
		}
	}

	return warnings
}

// checkAPIsWithoutValidation flags APIs that accept input but have no validation.
func checkAPIsWithoutValidation(app *ir.Application) []Warning {
	var warnings []Warning

	for _, ep := range app.APIs {
		if len(ep.Params) == 0 {
			continue
		}
		if len(ep.Validation) > 0 {
			continue
		}
		// Skip read-only endpoints — they're less risky
		method := strings.ToLower(httpMethod(ep.Name))
		if method == "get" {
			continue
		}
		warnings = append(warnings, Warning{
			Category: "missing-validation",
			Message:  fmt.Sprintf("API '%s' accepts %d parameters but has no validation rules", ep.Name, len(ep.Params)),
			Target:   ep.Name,
		})
	}

	return warnings
}

// checkEmptyWorkflows flags workflows with no steps.
func checkEmptyWorkflows(app *ir.Application) []Warning {
	var warnings []Warning

	for _, wf := range app.Workflows {
		if len(wf.Steps) == 0 {
			warnings = append(warnings, Warning{
				Category: "empty-workflow",
				Message:  fmt.Sprintf("Workflow triggered by '%s' has no steps", wf.Trigger),
				Target:   wf.Trigger,
			})
		}
	}

	return warnings
}

// renderLintReport produces a lint-report.md.
func renderLintReport(app *ir.Application, warnings []Warning) string {
	var b strings.Builder

	b.WriteString("# Lint Report\n\n")
	b.WriteString("Generated by Human compiler quality engine.\n\n")

	fmt.Fprintf(&b, "**Summary:** %d warnings\n\n", len(warnings))

	if len(warnings) == 0 {
		b.WriteString("No lint issues found.\n")
		return b.String()
	}

	b.WriteString("## Warnings\n\n")
	b.WriteString("| Category | Target | Message |\n")
	b.WriteString("|----------|--------|---------|\n")
	for _, w := range warnings {
		fmt.Fprintf(&b, "| %s | %s | %s |\n", w.Category, w.Target, w.Message)
	}
	b.WriteString("\n")

	return b.String()
}
