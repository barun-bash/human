package quality

import (
	"fmt"
	"strings"

	"github.com/barun-bash/human/internal/ir"
)

// TraceEntry maps an IR element to its generated file paths and test coverage status.
type TraceEntry struct {
	Source    string   // human syntax element
	Category string   // "data", "page", "api", "auth", "workflow"
	Generated []string // expected file paths relative to outputDir
	TestFiles []string
	Status    string   // "covered", "partial", "untested"
}

// generateTraceabilityMatrix produces a traceability matrix document from the IR.
func generateTraceabilityMatrix(app *ir.Application, config *ir.BuildConfig) string {
	entries := buildTraceEntries(app, config)

	var b strings.Builder

	b.WriteString("# Traceability Matrix\n\n")
	fmt.Fprintf(&b, "Application: **%s**\n\n", app.Name)
	b.WriteString("Generated by Human compiler quality engine.\n\n")

	// Summary table
	b.WriteString("## Summary\n\n")
	b.WriteString("| Category | Statements | Covered | Partial | Untested |\n")
	b.WriteString("|----------|------------|---------|---------|----------|\n")

	categories := []string{"data", "page", "api", "auth", "workflow"}
	totals := map[string]int{}
	covered := map[string]int{}
	partial := map[string]int{}
	untested := map[string]int{}

	for _, e := range entries {
		totals[e.Category]++
		switch e.Status {
		case "covered":
			covered[e.Category]++
		case "partial":
			partial[e.Category]++
		case "untested":
			untested[e.Category]++
		}
	}

	for _, cat := range categories {
		if totals[cat] == 0 {
			continue
		}
		fmt.Fprintf(&b, "| %s | %d | %d | %d | %d |\n", cat, totals[cat], covered[cat], partial[cat], untested[cat])
	}
	b.WriteString("\n")

	// Detail table
	b.WriteString("## Details\n\n")
	b.WriteString("| Source | Category | Generated Files | Test Files | Status |\n")
	b.WriteString("|--------|----------|-----------------|------------|--------|\n")
	for _, e := range entries {
		gen := strings.Join(e.Generated, ", ")
		if gen == "" {
			gen = "—"
		}
		tests := strings.Join(e.TestFiles, ", ")
		if tests == "" {
			tests = "—"
		}
		fmt.Fprintf(&b, "| %s | %s | %s | %s | %s |\n", e.Source, e.Category, gen, tests, e.Status)
	}
	b.WriteString("\n")

	return b.String()
}

// buildTraceEntries maps each IR element to expected generated files.
func buildTraceEntries(app *ir.Application, config *ir.BuildConfig) []TraceEntry {
	var entries []TraceEntry

	frontend := ""
	backend := ""
	if config != nil {
		frontend = strings.ToLower(config.Frontend)
		backend = strings.ToLower(config.Backend)
	}

	// Data models → migration + type file + model file
	for _, model := range app.Data {
		kebab := toKebabCase(model.Name)
		e := TraceEntry{
			Source:   fmt.Sprintf("data: %s", model.Name),
			Category: "data",
		}

		// Migration
		e.Generated = append(e.Generated, fmt.Sprintf("sql/001_create_%s.sql", strings.ToLower(model.Name)))

		// Backend model file
		switch {
		case strings.Contains(backend, "node"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/models/%s.ts", kebab))
		case strings.Contains(backend, "python"):
			e.Generated = append(e.Generated, fmt.Sprintf("python/models/%s.py", strings.ToLower(model.Name)))
		case strings.Contains(backend, "go"):
			e.Generated = append(e.Generated, fmt.Sprintf("go/models/%s.go", strings.ToLower(model.Name)))
		}

		// Frontend type file
		switch {
		case strings.Contains(frontend, "react"), strings.Contains(frontend, "vue"), strings.Contains(frontend, "svelte"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/types/%s.ts", kebab))
		case strings.Contains(frontend, "angular"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/app/models/%s.model.ts", kebab))
		}

		e.TestFiles = append(e.TestFiles, fmt.Sprintf("__tests__/%s-edge.test.ts", kebab))
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	// Pages → component files
	for _, page := range app.Pages {
		kebab := toKebabCase(page.Name)
		e := TraceEntry{
			Source:   fmt.Sprintf("page: %s", page.Name),
			Category: "page",
		}

		switch {
		case strings.Contains(frontend, "react"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/pages/%s.tsx", page.Name))
		case strings.Contains(frontend, "vue"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/pages/%s.vue", page.Name))
		case strings.Contains(frontend, "angular"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/app/pages/%s/%s.component.ts", kebab, kebab))
		case strings.Contains(frontend, "svelte"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/routes/%s/+page.svelte", kebab))
		}

		e.TestFiles = append(e.TestFiles, fmt.Sprintf("__tests__/%s.component.test.ts", kebab))
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	// API endpoints → route files + test files
	for _, ep := range app.APIs {
		kebab := toKebabCase(ep.Name)
		e := TraceEntry{
			Source:   fmt.Sprintf("api: %s", ep.Name),
			Category: "api",
		}

		switch {
		case strings.Contains(backend, "node"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/routes/%s.ts", kebab))
		case strings.Contains(backend, "python"):
			e.Generated = append(e.Generated, fmt.Sprintf("python/routes/%s.py", strings.ToLower(ep.Name)))
		case strings.Contains(backend, "go"):
			e.Generated = append(e.Generated, fmt.Sprintf("go/handlers/%s.go", strings.ToLower(ep.Name)))
		}

		e.TestFiles = append(e.TestFiles, fmt.Sprintf("__tests__/%s.test.ts", kebab))
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	// Auth → middleware files
	if app.Auth != nil {
		e := TraceEntry{
			Source:   "security: auth",
			Category: "auth",
		}
		switch {
		case strings.Contains(backend, "node"):
			e.Generated = append(e.Generated, "node/src/middleware/auth.ts")
		case strings.Contains(backend, "python"):
			e.Generated = append(e.Generated, "python/middleware/auth.py")
		case strings.Contains(backend, "go"):
			e.Generated = append(e.Generated, "go/middleware/auth.go")
		}
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	// Policies → middleware files
	for _, policy := range app.Policies {
		e := TraceEntry{
			Source:   fmt.Sprintf("policy: %s", policy.Name),
			Category: "auth",
		}
		switch {
		case strings.Contains(backend, "node"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/middleware/%s-policy.ts", toKebabCase(policy.Name)))
		case strings.Contains(backend, "python"):
			e.Generated = append(e.Generated, fmt.Sprintf("python/middleware/%s_policy.py", strings.ToLower(policy.Name)))
		case strings.Contains(backend, "go"):
			e.Generated = append(e.Generated, fmt.Sprintf("go/middleware/%s_policy.go", strings.ToLower(policy.Name)))
		}
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	// Workflows → event handler files
	for _, wf := range app.Workflows {
		trigger := strings.ReplaceAll(strings.ToLower(wf.Trigger), " ", "-")
		e := TraceEntry{
			Source:   fmt.Sprintf("when: %s", wf.Trigger),
			Category: "workflow",
		}
		switch {
		case strings.Contains(backend, "node"):
			e.Generated = append(e.Generated, fmt.Sprintf("node/src/events/%s.ts", trigger))
		case strings.Contains(backend, "python"):
			e.Generated = append(e.Generated, fmt.Sprintf("python/events/%s.py", strings.ReplaceAll(strings.ToLower(wf.Trigger), " ", "_")))
		case strings.Contains(backend, "go"):
			e.Generated = append(e.Generated, fmt.Sprintf("go/events/%s.go", strings.ReplaceAll(strings.ToLower(wf.Trigger), " ", "_")))
		}
		e.Status = traceStatus(e.Generated, e.TestFiles)
		entries = append(entries, e)
	}

	return entries
}

// traceStatus determines coverage status based on generated and test files.
func traceStatus(generated, testFiles []string) string {
	if len(generated) == 0 {
		return "untested"
	}
	if len(testFiles) > 0 {
		return "covered"
	}
	return "partial"
}

// renderTraceabilitySection produces a summary section for the build report.
func renderTraceabilitySection(entries []TraceEntry) string {
	var b strings.Builder

	b.WriteString("## Traceability\n\n")

	covered := 0
	partial := 0
	untestedCount := 0
	for _, e := range entries {
		switch e.Status {
		case "covered":
			covered++
		case "partial":
			partial++
		case "untested":
			untestedCount++
		}
	}

	fmt.Fprintf(&b, "**Summary:** %d statements — %d covered, %d partial, %d untested\n\n",
		len(entries), covered, partial, untestedCount)

	return b.String()
}
